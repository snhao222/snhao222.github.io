[{"title":"CoDL：Efficient CPU-GPU Co-execution for Deep Learning Inference on Mobile Devices","url":"/2022/10/13/CoDL%EF%BC%9AEfficient%20CPU-GPU%20Co-execution%20for%20Deep%20Learning%20Inference%20on%20Mobile%20Devices/","content":"\n 来        源：MobiSys ‘22: Proceedings of the 20th Annual International Conference on Mobile Systems, Applications and ServicesJune 2022 Pages 209–221https://doi.org/10.1145/3498361.3538932\n 原文速递：CoDL：Efficient CPU-GPU Co-execution for Deep Learning Inference on Mobile Devices\n\n1.Background &amp; Motivation当前，深度学习已经成为众多移动应用的支柱。由于隐私性，网络弹性和云计算开销上的优势，在边缘设备上进行推理成为一种趋势。然而，边缘设备的性能有限，只有在推理轻量小模型时才能获得能够容忍的推理速度，比如在移动处理器上运行YOLO目标检测网络具有超200ms的延时。为了能够在移动设备上缩短大模型推理的时延，该文致力于同时利用移动设备上的CPU和GPU来加速推理。该方案可行的两个主要原因是：\n\n1）与运行速度比CPU快一个数量级的服务器GPU不同，移动CPU和GPU在DL推理上具有近似的性能，因此可以进行并行推理；\n2）与服务器上CPU和GPU有独立的内存不同，移动设备的CPU和GPU具有统一的内存空间，可以避免不同内存间的数据复制。\n\n然而，现有的协同执行系统存在以下问题：\n\n1）在不同的处理器间使用相同的数据类型。统一的数据类型在多种处理器上的处理效率是不同的，如图1，在Adreno GPU上使用Image类型的数据比buffer类型更高效；\n\n    \n\n\n图1 使用buffer和image数据类型进行3×3卷积的时延对比\n\n2）处理器间的数据传输开销是不可忽视的，特别是对于小尺寸的算子。如图2，CPU和GPU并行推理存在数据类型转换（DT）、数据映射（M）、同步（Pre-sync &amp; Post-sync）和数据解映射四种额外开销。对于小算子，额外开销可能会占据总开销的主要部分（图3）；\n\n    \n\n\n图2 CPU-GPU协同执行的时延组成\n\n\n    \n\n\n图3 形状为的1×1卷积的计算时延和数据共享开销\n\n3）平衡的工作负载分割需要轻量且准确的时延预测器。现有协同执行系统大都使用轻量的时延预测模型去指导工作负载的切分，然而如表1所示，轻量的模型虽然适合于在线预测，但准确性很差（&lt;10%），这是由于执行的时延并不是FLOPs的线性函数，而是受平台特性影响的（图4）。同时，还有一些工作致力于准确的时延预测，例如nn-Meter，但由于缺乏对部署平台特性的知识，其获得高精度的代价是需要运行大规模模型，不适合在移动设备上部署。\n表1 两种时延预测器的±10%准确度和模型尺寸\n\n\n    \n\n\n\n    \n\n\n图4 （a）GPU（b）CPU对FLOPs增加表现出的非线性\n\n\n2. Contributions\n1）深入分析CPU+GPU协同推理的性能瓶颈；\n2）提出CPU和GPU间的多类型数据共享机制，通过设计多维分割和算子链来减小数据共享开销；\n3）提出轻量的准确时延预测方法；\n4）在设备上部署端到端的CoDL框架，验证其相较于SOTA方案的优点。\n\n3.Design DetailsCoDL的系统设计遵循三个原则：\n\n1）充分利用每个处理器的计算能力；\n2）最小化数据共享的额外开销；\n3）多种处理器间的工作负载最优分割。\n\nCoDL的系统架构和工作流程如图5所示，其由离线和在线两个阶段组成。\n\n    \n\n\n图5 CoDL的系统架构和工作流程\n\n在离线阶段，CoDL设计了一个轻量的高效时延预测器用于指导在现阶段的算子切分。在线阶段包含算子分割器和算子协同执行器两个模块，算子分割器用于找出最优算子分割方案，其使用多维数据分割和算子链两种技术得到最优方案。算子分割器首先通过多维数据分割找到每个算子的最优分割维度（H，OC）和分割比作为基础方案。基于分割方案，使用算子链技术将算子组成链状，使得连上的算子不需要共享数据。算子协同执行器基于分割方案在处理器上协同运行工作负载，并针对不同处理器使用处理器友好的数据类型。如图6，CoDL在CPU和GPU间共享数据，将GPU友好型数据转化为CPU友好型数据交给CPU处理，之后CPU和GPU并行执行一条算子链上的算子。最终，CPU的推理结果被转换回GPU友好型数据和GPU的推理结果合并。\n\n    \n\n\n图6 一个算子链的协同执行\n\n3.1多友好型数据共享3.1.1多维数据分割在张量的不同维度上进行分割会产生不同的性能影响，图7展示了在OC和H维度上进行张量分割的情况。虽然在H维度上进行分割可以减小数据共享量（模型权重是固定不变的，可以预分配），但相较于OC维度上的分割，在H和W较小时可能会导致较低的处理器利用率（图8）。因此，分割的维度应该由每个算子的形状决定。CoDL的多维数据分割基于提出的时延预测器，可以通过给定的输入算子设置、分割方案预测并行执行的总时延。基于预测的时延找到DL模型每个算子的最优分割维度和分割比。CoDL针对每个算子预测不同分割方案的总时延，预测时延最小的方案的分割维度将被选择。\n\n    \n\n\n图7 沿（a）OC（b）H进行数据分割示意\n\n\n    \n\n\n图8 不同张量尺寸下CPU+GPU相较于单CPU执行的加速\n\n3.1.2算子链为了减少数据同步的次数，该文提出算子链技术，如图9，数据只需要在链上的开始和结束的算子上进行同步，其余算子只需使用本地数据。\n\n    \n\n\n图9 算子链示意\n\n虽然算子链可以有效减小数据同步的开销，但算子链越长需要padding的数据尺寸越大，将会造成更大的计算量，如图10所示，当算子链过长时，总时延可能反而会增大。\n\n    \n\n\n图10 有无算子链的时延对比\n\n为了寻找能够最好地平衡数据同步和计算开销的算子链，该文提出了一个greedy-like算法。\n3.2 非线性并行执行时延预测数据分割和算子链技术都依赖于算子协同执行的时延预测，然而现有系统无法实现准确且轻量的时延预测，主要由于\n\n1）没有考虑数据共享的开销；\n2）由于忽视了应用平台的知识，预测器无法既准确又轻量。\n\n本文准确且轻量的时延预测器通过以下方法实现。\n\n1）引入所有数据共享的开销，T=T_{trans}+T_{map}+T_{psync}+max(T_{comp}^{cpu},T_{comp}^{gpu})；\n2）通过分析性地对由平台特征引起的非线性延迟响应建模，降低学习的难度。基于对非线性延迟响应的分析，该文建立了如下时延预测的模型\n\nT_{kernel}=\\lceil\\frac{Size_{output}}{Size_{block}\\cdot Core ＃} \\rceil \\cdot \\lceil\\frac{Size_{block}}{Size_{basicUnit}} \\rceil \\cdot t_{basicUnit}由于非线性已经被提取，只需使用轻量的线性回归模型学习给定处理器执行一个基本单元的时延即可。\n\n4. Comments本文提出了一个在移动设备的CPU和GPU上协同执行模型推理的系统架构和方法，许多方法的提出基于作者对大量实验现象的观察。通过联系实验现象和系统基本特性，该文实现了针对于移动设备的准确且轻量的时延预测。同时，该文数据分割和算子链的设计也具有启发意义。\n","categories":["Paper Notes"]},{"title":"Neurosurgeon：Collaborative Intelligence Between the Cloud and Mobile Edge","url":"/2022/10/20/Neurosurgeon/","content":"\n 来        源：ASPLOS ‘17: Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems - April 2017 - Pages 615–629https://doi.org/10.1145/3037697.3037698\n 原文速递：Neurosurgeon: Collaborative Intelligence Between the Cloud and Mobile Edge\n\n1. Background &amp; Motivation当前的智能应用，比如Apple Siri，Google Now和Microsoft Cortana，计算过程完全在云端进行。这种云计算范式通过网络传输用户原始到云数据中心，不仅对数据中心造成了很大的压力，还存在很高的通信时延。随着手机等移动设备的计算能力增强，能否将一部分数据计算从云端移至移动设备上进行值得研究。\n1.1 云中心计算现状\n    \n\n\n图1 AlexNet延迟分解\n\n\n    \n\n\n图2 AlextNet能耗分解\n\n\n1）对于3G和LTE网络，数据传输时延往往高于移动设备计算时延；\n2）云计算具备很大的计算优势，但经常由于数据传输时延高而失去优势；\n3）移动设备本地计算往往获得更低的时延和能耗，但在快速WiFi网络中，云计算的性能更佳。\n\n1.2 计算分配基于对云中心计算现状的研究，同时考虑到DNN的层结构很适合进行计算分割，该文考虑云端间的层级计算分配。\n\n    \n\n\n图3 AlexNet每层的执行时间和输出数据尺寸\n\n\n    \n\n\n图4 选择不同分割点时的时延和能耗\n\n\n1）由于每层的类型和在模型中所处的位置不同，具备不同的计算和数据需求；\n2）卷积和池化层的计算时延较小，而全连接层的时延较高；\n3）卷积和池化层往往在模型的前部，全连接层在后部；\n4）卷积层增加输出数据量，池化层减少输出数据量。前几层的数据量逐渐减小，后几层的数据量小于原始输入；\n5）“前几层的数据量逐渐减小，后几层的计算时延逐渐增加”的发现说明：在模型中部进行计算分割并由云端协同执行推理能够取得性能增益。\n\n2. Contributions\n1）深入的现状分析。对云中心计算方案进行分析，发现数据的无线网络传输时现有方法的瓶颈，在移动端进行DNN推理往往可以获得更低的时延和能耗；\n2）DNN计算和数据量研究。深入研究8种DNN的层级别时延和数据量特性，发现DNN的不同层具有不同的计算量和数据尺寸特性；\n3）云-端DNN计算分配。发现层级别的DNN分割能够获得性能增益，设计了一个系统方法在不同应用的DNN中寻找最优分割点来减小时延和能耗；\n4）设计Neurosurgeon运行时系统和层性能预测模型。\n\n3. Design DetailsNeurosurgeon由一个部署阶段和一个用来管理云-端分割的运行时系统组成，如图5。\n\n    \n\n\n图5 Neurosurgeon系统组成\n\n在部署阶段-Neurosurgeon通过分析移动设备和服务器生成各种DNN层类型的预测模型，该分析过程与DNN应用无关，对于移动设备和服务器平台只需进行一次，之后模型将被储存在移动设备和服务器上用于对每层的时延和能耗进行预测。\n在运行时-Neurosurgeon动态地决定DNN的最佳分割点，如图5所示，该过程分为以下步骤：1）Neurosurgeon分析并提取DNN每层的类型和配置；2）系统使用存储的层性能模型估计在云和移动设备上执行每一层的时延和能耗；3）综合考虑每个预测结果和当前无线连接带宽及数据中心负载情况，Neuro surgeon选择针对时延或能耗的最佳分割点；4）Neurosurgeon在云-端间协同执行DNN。\n3.1 性能预测模型对于每种层类型，Neurosurgeon基于该层的配置建立一个回归模型预测时延和能耗，使用GFLOPS（每秒千兆浮点运算）作为性能预测的量度。\n1）卷积层和池化层\n对卷积层的回归模型基于两个参数变量：输入特征图的特征数量和输入特征图每个像素的计算量（(filter\\ size / stride)^2 \\times(＃\\ of\\ filters)）。对于池化层，使用输入、输出特征图的尺寸作为回归模型的参数变量.\n2）全连接层\n对于全连接层，使用输入神经元和输出神经元的数量作为回归模型的参数。对于Softmax和argmax层的处理类似。\n3）激活层\n激活层的参数较少，只有输入输出数据的一对一映射，因此使用神经元的数量作为回归模型的参数变量。对于标准化层的操作类似。\n3.2 动态DNN分割Neurosurgeon的DNN分割算法如下，Neurosurgeon首先分析组成目标DNN的各层(L_i)，并使用性能预测器获得每层在移动设备和服务器上计算的时延(TM_i)、(TC_i)和能耗(PM_i)、(PU\\times TU_i)。由于线性模型是十分简单的，该DNN分割算法是轻量且高效的。\n\n    \n\n\n4. CommentsNeurosurgeon是一个云-端协同的协同推理系统，能够相较云计算减少传输数据量，相较单机边缘计算提升计算速度，从而提高DNN推理的响应速度。然而，该系统存在许多不足之处：\n\n1）性能预测器准确度无法保证。该系统的性能预测器仅仅针对对不同层参数构建简单的线性或指数回归模型，虽然该模型执行很快，但如此简单的预测方法难以获得高预测精度，而较低的预测精度势必影响DNN分割算法的效果；\n2）对多层网络的性能预测不准确。该文仅使用每层网络时延和能耗的加和表示多层的性能，而实验表明运行多层网络的时延和能耗往往低于每层网络的加和，由错误的性能预测数据确定DNN分割点很难得到最优方案；\n3）云-端协同的方案受到一些限制。首先，云-端协同仍然受到网络条件限制，在网络环境较差时即便转为单机推理也存在时延增加的问题。其次，该方案仅适用于一台移动设备和一台服务器的协同推理，参与节点较少，灵活性较差。\n\n","categories":["Paper Notes"]},{"title":"PyTorch基础","url":"/2022/10/22/PyTorch%E5%9F%BA%E7%A1%80/","content":"1. 引言PyTorch是Facebook团队于2017年1月发布的一个深度学习框架，虽然晚于TensorFlow、Keras等框架，但自发布之日起，其关注度就在不断上升，目前在GitHub上的热度已超过Theano、Caffe、MXNet等框架。\nPyTorch是一个建立在Torch库之上的Python包，旨在加速深度学习应用。它提供一种类似Numpy的抽象方法来表征张量（或多维数组），可以利用GPU来加速训练。由于PyTorch采用了动态计算图（Dynamic Computational Graph）结构，且基于tape的Autograd系统的深度神经网络。其他很多框架，比如TensorFlow（TensorFlow2.0也加入了动态网络的支持）、Caffe、CNTK、Theano等，采用静态计算图。使用PyTorch，通过一种称为Reverse-mode auto-differentiation（反向模式自动微分）的技术，可以零延迟或零成本地任意改变你的网络的行为。Torch是PyTorch中的一个重要包，它包含了多维张量的数据结构以及基于其上的多种数学操作。自2015年谷歌开源TensorFlow以来，深度学习框架之争越来越激烈，全球多个看重AI研究与应用的科技巨头均在加大这方面的投入。PyTorch从2017年年初发布以来，可谓是异军突起，短时间内取得了一系列成果，成为明星框架。\nPyTorch由4个主要的包组成：\n\\cdottorch：类似于Numpy的通用数组库，可将张量类型转换为torch.cuda.TensorFloat，并在GPU上进行计算；\n\\cdottorch.autograd：用于构建计算图形并自动获取梯度的包；\n\\cdottorch.nn：具有共享层和损失函数的神经网络库；\n\\cdottorch.optim：具有通用优化算法（如SGD、Adam等）的优化包。\n2. Numpy与Tensor上一内容介绍了Numpy，了解到其存取数据非常方便，而且还拥有大量的函数，所以深得数据处理、机器学习者喜爱。这节内容将介绍PyTorch的Tensor，它可以是零维（又称为标量或一个数）、一维、二维及多维的数组。Tensor自称为神经网络界的Numpy，它与Numpy相似，二者可以共享内存，且之间的转换非常方便和高效。不过它们也有不同之处，最大的区别就是Numpy会把ndarray放在CPU中进行加速运算，而由Torch产生的Tensor会放在GPU中进行加速运算（假设当前环境有GPU）。\n2.1 创建Tensor创建Tensor的方法有很多，可以从列表或ndarray等类型进行构建，也可根据指定的形状构建。常见的创建Tensor的方法可参考表1。\n表1 常见的创建Tensor的方法\n\n\n    \n\n\n\nimport torch#根据list数据生成Tensortorch.Tensor([1,2,3,4,5,6])#根据指定形状生成Tensortorch.Tensor(2,3)#根据给定的数组生成Tensort=torch.Tensor([[1,2,3],[4,5,6]])#查看Tensor的形状t.size()#shape与size()等价t.shape#根据已有形状创建Tensortorch.Tensor(t.size())\n#生成一个单位矩阵torch.eye(2,2)#自动生成全是0的矩阵torch.zeros(2,3)#根据规则生成数据torch.linspace(1,10,4)#生成满足均匀分布随机数torch.rand(2,3)#生成满足标准分布随机数torch.randn(2,3)#返回所给数据形状相同，值全为0的张量torch.zeros_like(torch.rand(2,3))\n2.2 修改Tensor形状在处理数据、构建网络层等过程中，经常需要了解Tensor的形状、修改Tensor的形状。与修改Numpy的形状类似，修改Tenor的形状也有很多类似函数，具体可参考表2。\n表2 常用修改Tensor形状的函数\n\n\n    \n\n\n#生成一个形状为2x3的矩阵x = torch.randn(2, 3)#查看矩阵的形状x.size()   #结果为torch.Size([2, 3])#查看x的维度x.dim()    #结果为2#把x变为3x2的矩阵x.view(3,2)#把x展平为1维向量y=x.view(-1)  y.shape#添加一个维度z=torch.unsqueeze(y,0)#查看z的形状z.size()   #结果为torch.Size([1, 6])#计算Z的元素个数z.numel()   #结果为6\n\ntorch.view与torch.reshpae的异同1）reshape()可以由torch.reshape()，也可由torch.Tensor.reshape()调用。但view()只可由torch.Tensor.view()来调用；2）对于一个将要被view的Tensor，新的size必须与原来的size与stride兼容。否则，在view之前必须调用contiguous()方法；3）同样也是返回与input数据量相同，但形状不同的Tensor。若满足view的条件，则不会copy，若不满足，则会copy；4）如果你只想重塑张量，请使用torch.reshape。如果你还关注内存使用情况并希望确保两个张量共享相同的数据，请使用torch.view。\n\n2.3 索引操作Tensor的索引操作与Numpy类似，一般情况下索引结果与源数据共享内存。从Tensor获取元素除了可以通过索引，也可以借助一些函数，常用的选择函数可参考表3。\n表3 常用索引操作函数\n\n\n    \n\n\n设置一个随机种子torch.manual_seed(100) #生成一个形状为2x3的矩阵x = torch.randn(2, 3)#根据索引获取第1行，所有数据x[0,:]#获取最后一列数据x[:,-1]#生成是否大于0的Byter张量mask=x&gt;0#获取大于0的值torch.masked_select(x,mask)#获取非0下标,即行，列索引torch.nonzero(mask)#获取指定索引对应的值,输出根据以下规则得到#out[i][j] = input[index[i][j]][j]  # if dim == 0#out[i][j] = input[i][index[i][j]]  # if dim == 1index=torch.LongTensor([[0,1,1]])torch.gather(x,0,index)index=torch.LongTensor([[0,1,1],[1,1,1]])a=torch.gather(x,1,index)#把a的值返回到一个2x3的0矩阵中z=torch.zeros(2,3)z.scatter_(1,index,a)\n2.4 广播机制广播机制是向量运算的重要技巧。除了Numpy支持广播机制外，PyTorch也支持广播机制。\nimport torchimport numpy as npA = np.arange(0, 40, 10).reshape(4, 1)B = np.arange(0, 3)#把ndarray转换为TensorA1=torch.from_numpy(A)  #形状为4x1B1=torch.from_numpy(B)  #形状为3#Tensor自动实现广播C=A1+B1#我们可以根据广播机制，手工进行配置#根据规则1，B1需要向A1看齐，把B变为（1, 3）B2=B1.unsqueeze(0)  #B2的形状为1x3#使用expand函数重复数组，分别的4x3的矩阵A2=A1.expand(4, 3)B3=B2.expand(4, 3)#然后进行相加,C1与C结果一致C1=A2+B3\n2.5 逐元素操作与Numpy一样，Tensor也有逐元素操作（Element-Wise），且操作内容相似，但使用函数可能不尽相同。大部分数学运算都属于逐元素操作，其输入与输出的形状相同。常见的逐元素操作可参考表4。\n表4 常见逐元素操作\n\n\n    \n\n\n\n这些操作均会创建新的Tensor，如果需要就地操作，可以使用这些方法的下划线版本，例如abs_。\n\nt = torch.randn(1, 3)t1 = torch.randn(3, 1)t2 = torch.randn(1, 3)#t+0.1*(t1/t2)torch.addcdiv(t, 0.1, t1, t2)#计算sigmoidtorch.sigmoid(t)#将t限制在[0,1]之间torch.clamp(t,0,1)#t+2进行就地运算t.add_(2)\n2.6 归并操作归并操作顾名思义，就是对输入进行归并或合计等操作，这类操作的输入输出形状一般并不相同，而且往往是输入大于输出形状。归并操作可以对整个Tensor，也可以沿着某个维度进行归并。常见的归并操作可参考表5。\n表5 常见归并操作\n\n\n    \n\n\n\n归并操作一般涉及一个dim参数，指定沿哪个维进行归并。另一个参数是keepdim，说明输出结果中是否保留维度1，缺省情况是False，即不保留。\n\n#生成一个含6个数的向量a=torch.linspace(0,10,6)#使用view方法，把a变为2x3矩阵a=a.view((2,3))#沿y轴方向累加，即dim=0b=a.sum(dim=0)   #b的形状为[3]#沿y轴方向累加，即dim=0,并保留含1的维度b=a.sum(dim=0,keepdim=True) #b的形状为[1,3]\n2.7 比较操作比较操作一般是进行逐元素比较，有些是按指定方向比较。常用的比较函数可参考表6。\n表6 常用的比较函数\n\n\n    \n\n\nx=torch.linspace(0,10,6).view(2,3)#求所有元素的最大值torch.max(x)   #结果为10#求y轴方向的最大值torch.max(x,dim=0)  #结果为[6,8,10]#求最大的2个元素torch.topk(x,1,dim=0)  #结果为[6,8,10],对应索引为tensor([[1, 1, 1])\n2.8 矩阵操作机器学习和深度学习中存在大量的矩阵运算，常用的算法有两种：一种是逐元素乘法，另外一种是点积乘法。PyTorch中常用的矩阵函数可参考表7。\n表7 常用矩阵函数\n\n\n    \n\n\n\n1）Torch的dot与Numpy的dot有点不同，Torch中的dot是对两个为1D张量进行点积运算，Numpy中的dot无此限制；2）mm是对2D的矩阵进行点积，bmm对含batch的3D矩阵进行点积运算；3）转置运算会导致存储空间不连续，需要调用contiguous方法转为连续。\n\na=torch.tensor([2, 3])b=torch.tensor([3, 4])torch.dot(a,b)  #运行结果为18x=torch.randint(10,(2,3))y=torch.randint(6,(3,4))torch.mm(x,y)x=torch.randint(10,(2,2,3))y=torch.randint(6,(2,3,4))torch.bmm(x,y)\n2.9 PyTorch与Numpy比较PyTorch与Numpy有很多类似的地方，并且有很多相同的操作函数名称，或虽然函数名称不同但含义相同；当然也有一些虽然函数名称相同，但含义不尽相同。有些很容易混淆，Numpy与Pytorch函数的一些主要区别可参考表8。\n表8 Pytorch与Numpy函数对照表\n\n\n    \n\n\n3. 使用Tensor及Autograd实现机器学习在神经网络中，一个重要内容就是进行参数学习，而参数学习离不开求导，那么PyTorch是如何进行求导的呢？现在大部分深度学习架构都有自动求导的功能，PyTorch也不例外，torch.autograd包就是用来自动求导的。Autograd包为张量上所有的操作提供了自动求导功能，而torch.Tensor和torch.Function为Autograd的两个核心类，它们相互连接并生成一个有向无环图（DAG）。\n本节将使用PyTorch的autograd自动求导包及对应的Tensor，利用自动反向传播来求梯度，无须手工计算梯度。\n1）导入需要的库。\nimport torchimport numpy as npfrom matplotlib import pyplot as plt\n2）生成训练数据，并可视化数据分布情况。\nt.manual_seed(100) dtype = t.float#生成x坐标数据，x为tenor，需要把x的形状转换为100x1x = t.unsqueeze(torch.linspace(-1, 1, 100), dim=1) #生成y坐标数据，y为tenor，形状为100x1，另加上一些噪声y = 3*x.pow(2) +2+ 0.2*torch.rand(x.size())   # 画图，把tensor数据转换为numpy数据plt.scatter(x.numpy(), y.numpy())plt.show()\n\n    \n\n\n3）初始化权重参数。\n# 随机初始化参数，参数w、b为需要学习的，故需requires_grad=Truew = t.randn(1,1, dtype=dtype,requires_grad=True)b = t.zeros(1,1, dtype=dtype, requires_grad=True) \n4）训练模型。\nlr =0.001 # 学习率for ii in range(800):    # 前向传播，并定义损失函数loss    y_pred = x.pow(2).mm(w) + b    loss = 0.5 * (y_pred - y) ** 2    loss = loss.sum()    # 自动计算梯度，梯度存放在grad属性中    loss.backward()    # 手动更新参数，需要用torch.no_grad()，使上下文环境中切断自动求导的计算    with t.no_grad():        w -= lr * w.grad        b -= lr * b.grad    # 梯度清零        w.grad.zero_()        b.grad.zero_()\n5）可视化训练结果。\nplt.plot(x.numpy(), y_pred.detach().numpy(),&#x27;r-&#x27;,label=&#x27;predict&#x27;)#predictplt.scatter(x.numpy(), y.numpy(),color=&#x27;blue&#x27;,marker=&#x27;o&#x27;,label=&#x27;true&#x27;) # true dataplt.xlim(-1,1)plt.ylim(2,6)  plt.legend()plt.show()print(w, b)\n\n    \n\n\n运行结果：tensor([[2.9648]], requires_grad=True) tensor([[2.1145]], requires_grad=True)\n4. PyTorch神经网络工具箱4.1 神经网络核心组件神经网络看起来很复杂，节点很多，层数多，参数更多。但核心部分或组件不多，把这些组件确定后，这个神经网络基本就确定了。这些核心组件包括：1）层：神经网络的基本结构，将输入张量转换为输出张量。2）模型：层构成的网络。3）损失函数：参数学习的目标函数，通过最小化损失函数来学习各种参数。4）优化器：如何使损失函数最小，这就涉及优化器。当然这些核心组件不是独立的，它们之间，以及它们与神经网络其他组件之间有密切关系。为便于读者理解，我们可以把这些关键组件及相互关系，用图1表示。\n\n    \n\n\n图1 神经网络关键组件及相互关系示意图\n\n多个层链接在一起构成一个模型或网络，输入数据通过这个模型转换为预测值，然后损失函数把预测值与真实值进行比较，得到损失值（损失值可以是距离、概率值等），该损失值用于衡量预测值与目标结果的匹配或相似程度，优化器利用损失值更新权重参数，从而使损失值越来越小。这是一个循环过程，当损失值达到一个阀值或循环次数到达指定次数，循环结束。\n4.2 神经网络工具箱nn前面我们使用Autograd及Tensor实现机器学习实例时，需要做不少设置，如对叶子节点的参数requires_grad设置为True，然后调用backward，再从grad属性中提取梯度。对于大规模的网络，Autograd太过于底层和烦琐。为了简单、有效解决这个问题，nn是一个有效工具。在nn工具箱中有两个重要模块：nn.Model、nn.functional。\nnn中的大多数层（Layer）在functional中都有与之对应的函数。nn.functional中函数与nn.Module中的Layer的主要区别是后者继承Module类，会自动提取可学习的参数。而nn.functional更像是纯函数。两者功能相同，且性能也没有很大区别，那么如何选择呢？像卷积层、全连接层、Dropout层等因含有可学习参数，一般使用nn.Module，而激活函数、池化层不含可学习参数，可以使用nn.functional中对应的函数。\n4.2.1 nn.Modulenn.Module是nn的一个核心数据结构，它可以是神经网络的某个层（Layer），也可以是包含多层的神经网络。在实际使用中，最常见的做法是继承nn.Module，生成自己的网络/层。nn中已实现了绝大多数层，包括全连接层、损失层、激活层、卷积层、循环层等，这些层都是nn.Module的子类，能够自动检测到自己的Parameter，并将其作为学习参数，且针对GPU运行进行了cuDNN优化。\n4.2.2 nn.functionalnn中的层，一类是继承了nn.Module，其命名一般为nn.Xxx（第一个是大写），如nn.Linear、nn.Conv2d、nn.CrossEntropyLoss等。另一类是nn.functional中的函数，其名称一般为nn.funtional.xxx，如nn.funtional.linear、nn.funtional.conv2d、nn.funtional.cross_entropy等。从功能来说两者相当，基于nn.Moudle能实现的层，使用nn.funtional也可实现，反之亦然，而且性能方面两者也没有太大差异。不过在具体使用时，两者还是有区别，主要区别如下：\n\n1）nn.Xxx继承于nn.Module，nn.Xxx需要先实例化并传入参数，然后以函数调用的方式调用实例化的对象并传入输入数据。它能够很好地与nn.Sequential结合使用，而nn.functional.xxx无法与nn.Sequential结合使用。2）nn.Xxx不需要自己定义和管理weight、bias参数；而nn.functional.xxx需要自己定义weight、bias参数，每次调用的时候都需要手动传入weight、bias等参数，不利于代码复用。3）Dropout操作在训练和测试阶段是有区别的，使用nn.Xxx方式定义Dropout，在调用model.eval()之后，自动实现状态的转换，而使用nn.functional.xxx却无此功能。\n\n总的来说，两种功能都是相同的，但PyTorch官方推荐：具有学习参数的（例如，conv2d,linear,batch_norm)采用nn.Xxx方式。没有学习参数的（例如，maxpool、loss func、activation func）等根据个人选择使用nn.functional.xxx或者nn.Xxx方式。\n4.3 优化器PyTorch常用的优化方法都封装在torch.optim里面，其设计很灵活，可以扩展为自定义的优化方法。所有的优化方法都是继承了基类optim.Optimizer，并实现了自己的优化步骤。最常用的优化算法就是梯度下降法及其各种变种，这类优化算法通过使用参数的梯度值更新参数。\n使用优化器的一般步骤为：\n（1）建立优化器实例导入optim模块，实例化SGD优化器，这里使用动量参数momentum（该值一般在（0,1）之间），是SGD的改进版，效果一般比不使用动量规则的要好。\nimport torch.optim as optimoptimizer = optim.SGD(model.parameters(), lr=lr, momentum=momentum)\n\n 以下步骤在训练模型的for循环中。\n\n（2）向前传播把输入数据传入神经网络Net实例化对象model中，自动执行forward函数，得到out输出值，然后用out与标记label计算损失值loss。\nout = model(img)loss = criterion(out, label)\n（3）清空梯度缺省情况梯度是累加的，在梯度反向传播前，先需把梯度清零。\noptimizer.zero_grad()\n（4）反向传播基于损失值，把梯度进行反向传播。\nloss.backward()\n（5）更新参数基于当前梯度（存储在参数的.grad属性中）更新参数。\noptimizer.step()\n动态修改学习率参数\n修改参数的方式可以通过修改参数optimizer.params_groups或新建optimizer。新建optimizer比较简单，optimizer十分轻量级，所以开销很小。但是新的优化器会初始化动量等状态信息，这对于使用动量的优化器（momentum参数的SGD）可能会造成收敛中的震荡。所以，这里直接采用修改参数optimizer.params_groups。optimizer.param_groups：长度1的list，optimizer.param_groups[0]：长度为6的字典，包括权重参数、lr、momentum等参数。\nlen(optimizer.param_groups[0])运行结果：6\n动态修改学习率参数示例：\nfor epoch in range(num_epoches):#动态修改参数学习率    if epoch%5==0:        optimizer.param_groups[0][&#x27;lr&#x27;]*=0.1        print(optimizer.param_groups[0][&#x27;lr&#x27;])    for img, label in train_loader:######\n4.4 神经网络构建实例使用PyTorch构建神经网络使用的主要工具（或类）及相互关系如图2所示。如4.2节所述，构建网络层可基于Module类或函数（nn.functional）。\n\n    \n\n\n图2 PyTorch实现神经网络的主要工具及相互关系\n\n下面将利用神经网络完成对手写数字进行识别的实例，来说明如何借助nn工具箱来实现一个神经网络，并对神经网络有个直观了解。主要步骤有：\n\n1）利用PyTorch内置函数mnist下载数据集；2）利用torchvision对数据进行预处理，调用torch.utils建立一个数据迭代器；3）可视化源数据；4）利用nn工具箱构建神经网络模型；5）实例化模型，并定义损失函数及优化器；6）训练模型；7）可视化结果。\n\n神经网络的结构如图3所示，使用两个隐含层，每层激活函数为ReLU，最后使用torch.max(out,1)找出张量out最大值对应索引作为预测值。\n\n    \n\n\n图3 实例使用的神经网络结构图\n\n4.4.1 数据准备（1）导入模块\nimport numpy as npimport torch# 导入 PyTorch 内置的 mnist 数据from torchvision.datasets import mnist #导入预处理模块import torchvision.transforms as transformsfrom torch.utils.data import DataLoader#导入nn及优化器import torch.nn.functional as Fimport torch.optim as optimfrom torch import nn#导入画图库import matplotlib.pyplot as plt\n（2）定义超参数\ntrain_batch_size = 64test_batch_size = 128learning_rate = 0.01num_epoches = 20lr = 0.01momentum = 0.5\n（3）下载数据并对数据进行预处理\n#定义预处理函数，这些预处理依次放在Compose函数中。transform = transforms.Compose([transforms.ToTensor(),transforms.Normalize([0.5], [0.5])])#下载数据，并对数据进行预处理train_dataset = mnist.MNIST(&#x27;./data&#x27;, train=True, transform=transform, download=True)test_dataset = mnist.MNIST(&#x27;./data&#x27;, train=False, transform=transform)#dataloader是一个可迭代对象，可以想迭代器一样使用。train_loader = DataLoader(train_dataset, batch_size=train_batch_size, shuffle=True)test_loader = DataLoader(test_dataset, batch_size=test_batch_size, shuffle=False)\n\n1）transforms.Compose可以把一些转换函数组合在一起；2）Normalize([0.5],[0.5])对张量进行归一化，这里两个0.5分别表示对张量进行归一化的全局平均值和方差。因图像是灰色的只有一个通道，如果有多个通道，需要有多个数字，如3个通道，应该是Normalize([m1,m2,m3],[n1,n2,n3])；3）download参数控制是否需要下载，如果./data目录下已有MNIST，可选择False；4）用DataLoader得到生成器，这可节省内存；5）shuffle=True表示对数据进行打乱操作。\n\n4.4.2 可视化源数据examples = enumerate(test_loader)batch_idx, (example_data, example_targets) = next(examples)fig = plt.figure()for i in range(6):  plt.subplot(2,3,i+1)  plt.tight_layout()  plt.imshow(example_data[i][0], cmap=&#x27;gray&#x27;, interpolation=&#x27;none&#x27;)  plt.title(&quot;Ground Truth: &#123;&#125;&quot;.format(example_targets[i]))  plt.xticks([])  plt.yticks([])plt.show()\n\n    \n\n\n4.4.3 模型构建（1）构建网络\nclass Net(nn.Module):    &quot;&quot;&quot;    使用sequential构建网络，Sequential()函数的功能是将网络的层组合到一起    &quot;&quot;&quot;    def __init__(self, in_dim, n_hidden_1, n_hidden_2, out_dim):        super(Net, self).__init__()        self.layer1 = nn.Sequential(nn.Linear(in_dim, n_hidden_1),nn.BatchNorm1d(n_hidden_1))        self.layer2 = nn.Sequential(nn.Linear(n_hidden_1, n_hidden_2),nn.BatchNorm1d (n_hidden_2))        self.layer3 = nn.Sequential(nn.Linear(n_hidden_2, out_dim))    def forward(self, x):        x = F.relu(self.layer1(x))        x = F.relu(self.layer2(x))        x = self.layer3(x)        return x\n（2）实例化网络\n#检测是否有可用的GPU，有则使用，否则使用CPUdevice = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)#实例化网络model = Net(28 * 28, 300, 100, 10)model.to(device)# 定义损失函数和优化器criterion = nn.CrossEntropyLoss()optimizer = optim.SGD(model.parameters(), lr=lr, momentum=momentum)\n4.4.4 模型训练这里使用for循环进行迭代，其中包括对训练数据的训练模型，然后用测试数据的验证模型。\n（1）模型训练\n# 开始训练losses = []acces = []eval_losses = []eval_acces = []for epoch in range(num_epoches):    train_loss = 0    train_acc = 0    #将module设置为训练模式    model.train()\t#动态修改参数学习率    if epoch%5==0:        optimizer.param_groups[0][&#x27;lr&#x27;]*=0.1    for img, label in train_loader:        img=img.to(device)        label = label.to(device)        img = img.view(img.size(0), -1)        # 前向传播        out = model(img)        loss = criterion(out, label)        # 反向传播        optimizer.zero_grad()        loss.backward()        optimizer.step()        # 记录误差        train_loss += loss.item()        # 计算分类的准确率        _, pred = out.max(1)        num_correct = (pred == label).sum().item()        acc = num_correct / img.shape[0]        train_acc += acc    losses.append(train_loss / len(train_loader))    acces.append(train_acc / len(train_loader))    # 在测试集上检验效果    eval_loss = 0    eval_acc = 0\t# 将模型改为预测模式（会将所有的training属性设置为False）    model.eval()    for img, label in test_loader:        img=img.to(device)        label = label.to(device)        img = img.view(img.size(0), -1)        out = model(img)        loss = criterion(out, label)        # 记录误差        eval_loss += loss.item()        # 记录准确率        _, pred = out.max(1)        num_correct = (pred == label).sum().item()        acc = num_correct / img.shape[0]        eval_acc += acc    eval_losses.append(eval_loss / len(test_loader))    eval_acces.append(eval_acc / len(test_loader))    print(&#x27;epoch: &#123;&#125;, Train Loss: &#123;:.4f&#125;, Train Acc: &#123;:.4f&#125;, Test Loss: &#123;:.4f&#125;, Test Acc: &#123;:.4f&#125;&#x27;          .format(epoch, train_loss / len(train_loader), train_acc / len(train_loader),                      eval_loss / len(test_loader), eval_acc / len(test_loader)))\n迭代结果：\nepoch:0, Train Loss:0.9885, Train Acc:0.7987, Test Loss:0.5235, Test Acc:0.9073epoch:1, Train Loss:0.4622, Train Acc:0.9034, Test Loss:0.3412, Test Acc:0.9277epoch:2, Train Loss:0.3403, Train Acc:0.9208, Test Loss:0.2666, Test Acc:0.9376epoch:3, Train Loss:0.2761, Train Acc:0.9335, Test Loss:0.2217, Test Acc:0.9458epoch:4, Train Loss:0.2379, Train Acc:0.9410, Test Loss:0.1946, Test Acc:0.9511epoch:5, Train Loss:0.2174, Train Acc:0.9467, Test Loss:0.1922, Test Acc:0.9510epoch:6, Train Loss:0.2137, Train Acc:0.9482, Test Loss:0.1891, Test Acc:0.9517epoch:7, Train Loss:0.2120, Train Acc:0.9475, Test Loss:0.1872, Test Acc:0.9529epoch:8, Train Loss:0.2091, Train Acc:0.9487, Test Loss:0.1843, Test Acc:0.9530epoch:9, Train Loss:0.2067, Train Acc:0.9491, Test Loss:0.1831, Test Acc:0.9530epoch:10, Train Loss:0.2043, Train Acc:0.9498, Test Loss:0.1841, Test Acc:0.9540epoch:11, Train Loss:0.2046, Train Acc:0.9498, Test Loss:0.1826, Test Acc:0.9545epoch:12, Train Loss:0.2037, Train Acc:0.9497, Test Loss:0.1814, Test Acc:0.9542epoch:13, Train Loss:0.2038, Train Acc:0.9494, Test Loss:0.1813, Test Acc:0.9537epoch:14, Train Loss:0.2044, Train Acc:0.9500, Test Loss:0.1805, Test Acc:0.9547epoch:15, Train Loss:0.2034, Train Acc:0.9497, Test Loss:0.1828, Test Acc:0.9536epoch:16, Train Loss:0.2026, Train Acc:0.9508, Test Loss:0.1815, Test Acc:0.9533epoch:17, Train Loss:0.2025, Train Acc:0.9504, Test Loss:0.1838, Test Acc:0.9536epoch:18, Train Loss:0.2034, Train Acc:0.9501, Test Loss:0.1827, Test Acc:0.9542epoch:19, Train Loss:0.2034, Train Acc:0.9505, Test Loss:0.1804, Test Acc:0.9528\n该神经网络的结构比较简单，只用了两层，也没有使用Dropout层，迭代20次，测试准确率达到98%左右，效果还可以。不过，还是有提升空间，如果采用cnn、Dropout等层，应该还可以提升模型性能。\n（2）可视化训练及测试损失值\nplt.title(&#x27;trainloss&#x27;)plt.plot(np.arange(len(losses)), losses)plt.legend([&#x27;Train Loss&#x27;], loc=&#x27;upper right&#x27;)plt.show()\n\n    \n\n\n5. PyTorch数据处理工具箱上节利用PyTorch的torchvision、data等包，下载及预处理MNIST数据集。数据下载和预处理是机器学习、深度学习实际项目中耗时又重要的任务，尤其是数据预处理，关系到数据质量和模型性能，往往要占据项目的大部分时间。好在PyTorch为此提供了专门的数据下载、数据处理包，使用这些包，可极大地提高我们的开发效率及数据质量。\nPyTorch涉及数据处理（数据装载、数据预处理、数据增强等）主要工具包及相互关系如图4所示。\n\n    \n\n\n图4 PyTorch主要数据处理工具\n\n图4的左边是torch.utils.data工具包，它包括以下4个类。\n\n1）Dataset：是一个抽象类，其他数据集需要继承这个类，并且覆写其中的两个方法（_getitem、len__）；2）DataLoader：定义一个新的迭代器，实现批量（batch）读取，打乱数据（shuffle）并提供并行加速等功能；3）random_split：把数据集随机拆分为给定长度的非重叠的新数据集；4）*sampler：多种采样函数。\n\n图4中间是PyTorch可视化处理工具（Torchvision），其是PyTorch的一个视觉处理工具包，独立于PyTorch，需要另外安装。它包括4个类，各类的主要功能如下。\n\n1）datasets：提供常用的数据集加载，设计上都是继承自torch.utils.data.Dataset，主要包括MMIST、CIFAR10/100、ImageNet和COCO等；2）models：提供深度学习中各种经典的网络结构以及训练好的模型（如果选择pretrained=True），包括AlexNet、VGG系列、ResNet系列、Inception系列等；3）transforms：常用的数据预处理操作，主要包括对Tensor及PIL Image对象的操作；4）utils：含两个函数，一个是make_grid，它能将多张图片拼接在一个网格中；另一个是save_img，它能将Tensor保存成图片。\n\n5.1 utils.datautils.data包括Dataset和DataLoader。torch.utils.data.Dataset为抽象类，自定义数据集需要继承这个类，并实现两个函数，一个是__len__，另一个是__getitem，前者提供数据的大小（size），后者通过给定索引获取数据和标签。\\getitem__一次只能获取一个数据，所以需要通过torch.utils.data.DataLoader来定义一个新的迭代器，实现batch读取。下面定义一个简单的数据集，然后通过具体使用Dataset及DataLoader，获得一个直观的认识。\n（1）导入需要的模块。\nimport torchfrom torch.utils import dataimport numpy as np\n（2）定义获取数据集的类。\n该类继承基类Dataset，自定义一个数据集及对应标签。\nclass TestDataset(data.Dataset):#继承Dataset    def __init__(self):        self.Data=np.asarray([[1,2],[3,4],[2,1],[3,4],[4,5]])#一些由2维向量表示的数据集        self.Label=np.asarray([0,1,0,1,2])#这是数据集对应的标签    def __getitem__(self, index):        #把numpy转换为Tensor        txt=torch.from_numpy(self.Data[index])        label=torch.tensor(self.Label[index])        return txt,label     def __len__(self):        return len(self.Data)\n（3）获取数据集中数据。\nTest=TestDataset()print(Test[2])  #相当于调用__getitem__(2)print(Test.__len__())\n输出结果：\n(tensor([2, 1]), tensor(0))5\n以上数据以tuple返回，每次只返回一个样本。实际上，Dateset只负责数据的抽取，调用一次__getitem__只返回一个样本。如果希望批量处理（batch），还要同时进行shuffle和并行加速等操作，可选择DataLoader。DataLoader的格式为：\ndata.DataLoader(    dataset,    batch_size=1,    shuffle=False,    sampler=None,    batch_sampler=None,    num_workers=0,    collate_fn=&lt;function default_collate at 0x7f108ee01620&gt;,    pin_memory=False,    drop_last=False,    timeout=0,    worker_init_fn=None,)\n主要参数说明：\n\ndataset：加载的数据集；batch_size：批大小；shuffle：是否将数据打乱；sampler：样本抽样；num_workers：使用多进程加载的进程数，0代表不使用多进程；collate_fn：如何将多个样本数据拼接成一个batch，一般使用默认的拼接方式即可；pin_memory：是否将数据保存在pin memory区，pin memory中的数据转到GPU会快一些；drop_last：dataset中的数据个数可能不是batch_size的整数倍，drop_last为True会将多出来不足一个batch的数据丢弃。\n\ntest_loader = data.DataLoader(Test,batch_size=2,shuffle=False,num_workers=0)for i,traindata in enumerate(test_loader):    print(&#x27;i:&#x27;,i)    Data,Label=traindata    print(&#x27;data:&#x27;,Data)    print(&#x27;Label:&#x27;,Label)\n运行结果：\ni: 0data: tensor([[1, 2],        [3, 4]])Label: tensor([0, 1])i: 1data: tensor([[2, 1],        [3, 4]])Label: tensor([0, 1])i: 2data: tensor([[4, 5]])Label: tensor([2])\n可以看出，这是批量读取，可以像使用迭代器一样使用它，比如对它进行循环操作。不过由于它不是迭代器，我们可以通过iter命令将其转换为迭代器。\ndataiter=iter(test_loader)imgs,labels=next(dataiter)\n5.2 torchvision如图4所示，torchvision有4个功能模块：model、datasets、transforms和utils，上文中使用datasets下载了一些经典数据集，本节介绍如何使用datasets的ImageFolder处理数据集，以及如何使用transforms对数据进行预处理、增强等。\n5.2.1 ImageFolder当文件依据标签处于不同文件下时，如：─── data    ├── zhangliu    │   ├── 001.jpg    │   └── 002.jpg    ├── wuhua    │   ├── 001.jpg    │   └── 002.jpg    ……………..可以利用torchvision.datasets.ImageFolder来直接构造出dataset：\nloader = datasets.ImageFolder(path, transform=None)loader = data.DataLoader(dataset)\nImageFolder会将目录中的文件夹名自动转化成序列，当DataLoader载入时，标签自动就是整数序列了。\n5.2.2 transformstransforms提供了对PIL Image对象和Tensor对象的常用操作。\n（1）对PIL Image的常见操作\n\nScale/Resize：调整尺寸，长宽比保持不变；CenterCrop、RandomCrop、RandomSizedCrop：裁剪图片，CenterCrop和RandomCrop在crop时是固定size，RandomResizedCrop则是random size的crop；Pad：填充；ToTensor：把一个取值范围是[0,255]的PIL.Image转换成Tensor。形状为（H,W,C）的Numpy.ndarray转换成形状为[C,H,W]，取值范围是[0,1.0]的torch.FloatTensor；RandomHorizontalFlip：图像随机水平翻转，翻转概率为0.5；RandomVerticalFlip：图像随机垂直翻转；ColorJitter：修改亮度、对比度和饱和度。\n\n（2）对Tensor的常见操作\n\nNormalize：标准化，即，减均值，除以标准差；ToPILImage：将Tensor转为PIL Image。\n\n如果要对数据集进行多个操作，可通过Compose将这些操作像管道一样拼接起来，类似于nn.Sequential。\ntransforms.Compose([    #将给定的 PIL.Image 进行中心切割，得到给定的 size，    #size 可以是 tuple，(target_height, target_width)。    #size 也可以是一个 Integer，在这种情况下，切出来的图片形状是正方形。                transforms.CenterCrop(10),    #切割中心点的位置随机选取    transforms.RandomCrop(20, padding=0),    #把一个取值范围是 [0, 255] 的 PIL.Image 或者 shape 为 (H, W, C) 的 numpy.ndarray，    #转换为形状为 (C, H, W)，取值范围是 [0, 1] 的 torch.FloatTensor    transforms.ToTensor(),    #规范化到[-1,1]    transforms.Normalize(mean = (0.5, 0.5, 0.5), std = (0.5, 0.5, 0.5))])\n\n本内容旨在为读者提供PyTorch的一些主要基础内容，仅包含PyTorch完整内容的一部分，欲学习更多PyTorch相关内容，请查看：https://pytorch.org/docs/stable/index.html\n\n","categories":["Learning Materials"]},{"title":"NeuralPower：Predict and Deploy Energy-Efficient Convolutional Neural Networks","url":"/2022/10/21/NeuralPower/","content":"\n来        源：Proceedings of The 9th Asian Conference on Machine Learning, ACML 2017, Seoul, Korea, November 15-17, 2017\n原文速递：NeuralPower: Predict and Deploy Energy-Efficient Convolutional Neural Networks\n\n1. Background &amp; Motivation具有相近性能的网络模型运行时可能存在高达40倍的能耗（图1），为了设计节能的CNN网络，进行准确的时延、能耗预测是至关重要的。然而该文发现现有的性能预测方法存在一些不足：1）通常使用的CNN复杂度指标（如FLOPs）太粗略以至于无法预测真实平台的能耗，运行CNN的能耗不仅与网络结构有关，还需要考虑软硬件平台；2）未能定量地捕捉到CNN架构变化对运行时间、功率和能耗地影响。\n\n    \n\n\n图1 多种CNN架构的测试误差和能耗\n\n该文提出一种CNN时延、功率、能耗预测框架——NeuralPower，不需要在目标平台上实际运行CNN网络就可以在部署阶段预测网络的时延、功率和能耗。\n\n    \n\n\n图2 NeuralPower预测过程\n\n2. Contributions\n1)提出基于学习的多项式回归方法NeuralPower，是第一个预测CNN能耗的框架；\n2）NeuralPower能够预测CNN运行时间，相比现有方法取得68.5%的准确度提升；\n3）除了网络总体运行时延和能耗的预测，NeuralPower能够分析网络不同部分（每层）的时延和能耗，帮助模型设计人员分析模型瓶颈，更好地平衡精度和能耗。\n\n3. Design Details3.1 单层时延和能耗模型与其他工作不同，该文的目标是在不需要了解平台详细信息的情况下，使预测模型能够灵活应用到各种软硬件平台。该文提出一个基于学习的多项式回归模型用于学习不同CNN层类型的系数。\n层级时延模型：CNN模型一层的运行时延可以被表示为：\n\n    \n\n\n该模型由两部分组成，第一部分是对输入向量X_T\\in \\mathbb{R}^{D_T}的多项式函数，x_i是X_T的第i项，q_{ij}是多项式第j项对于x_i的指数，c_j是要学习的系数。X_T包含的层配置参数（如batch尺寸、输入输出尺寸等），对不同层类型，X_T的维度D_T有所不同。第二部分是特殊的多项式项\\digamma，封装了每层的物理操作（如内存访问的总次数和浮点运算的总次数），特殊多项式的项数根据层类型变化，c_s^\\prime是需要学习的参数。\n层级能耗模型：层能耗预测同样使用基于多项式的方法：\n\n    \n\n\n该模型同样由两部分组成，第一部分是输入向量X_P的多项式函数，m_{ij}是多项式第j项对于x_i的指数，z_j是要学习的系数。在模型的第二部分，z_k^\\prime为第k项需要学习的系数。\n该文注意到能耗的固有限制（计算负载增加时，能耗不再线性增长，存在一定上限），该文引入输入特征的对数项应对这种趋势以提高准确度。\n3.2 完整模型时延和能耗模型完整模型时延模型：对于一个N层串行模型，模型总时延可通过n层时延预测值\\hat{T}_n的加和获得：\n\n    \n\n\n完整模型功耗模型：平均功耗\\hat{P}_{avg}可由下式获得：\n\n    \n\n\n完整模型能耗模型：整个网络的能耗\\hat{E}_{total}可由下式获得：\n\n    \n\n\n3.3 模型选择（1）运行时间模型\nNeuralPower通过改变多项式模型的次数调整特征空间的尺度，应用Lasso压缩估计为每个多项式模型选择最佳模型，选择具有最低交叉验证均方根误差(RMSE)的模型，如图3，此时选择次数为2的模型更加合理。\n\n    \n\n\n图3 针对全连接层的最优多项式模型和其他多项式次数模型对比\n\n卷积层：卷积层是最耗时间和能耗的CNN部件，该文使用3次的多项式模型对该层建模，选择的特征向量包括：batch尺寸、输入tensor尺寸、卷积和尺寸、步长、padding尺寸和输出tensor尺寸。对于特殊项，使用能表示总计算量和内存访问量的多项式。\n全连接层：该文使用2次多项式回归模型，特征向量为：batch尺寸、输入tensor尺寸和输出tensor尺寸。\n池化层：该文使用3次多项式回归模型，输入的特征向量为：输入tensor尺寸、步长、卷积核尺寸和输出tensor尺寸。\n（2）能耗模型\n该文使用原始特征的对数形式作为多项式模型的特殊特征，并发现使用2次多项式模型对三种CNN层类型能取得最优交叉验证误差。\n3.4 模型评估（1）层级运行时间模型\n表1 NeuralPower的层级时延模型与SOTA方法对比\n\n\n    \n\n\n（2）层级能耗模型\n表2 CNN通用层的能耗模型\n\n\n    \n\n\n（3）完整模型运行时间模型\n该文完整模型运行时间的计算建模为各层时延的加和：\n表3 完整模型时延预测性能对比\n\n\n    \n\n\n该文发现各层运行时延的加和与完整模型运行时延相近。\n（4）完整模型能耗模型\n表4 完整模型功耗预测性能\n\n\n    \n\n\n表5 完整模型能耗预测性能\n\n\n    \n\n\n4. Comments\n1）该文考虑到其他基于单网络复杂度指标（e.g. FLOPs）方法的局限性，该文提出基于多项式模型的模型性能预测方法；\n2）该文不仅进行了模型运行时延预测，还设计了能耗的预测方法；\n3）该文的完整模型时延预测是对各层时延的加和，实验发现各层运行时延的加和与完整模型运行时延相近，该说法是否可靠还待考究。\n\n","categories":["Paper Notes"]},{"title":"Numpy基础","url":"/2022/10/10/Numpy%E5%9F%BA%E7%A1%80/","content":"在机器学习和深度学习中，图像、声音、文本等输入数据最终都要转换为数组或矩阵。如何有效地进行数组和矩阵的运算？这就需要充分利用Numpy。Numpy（Numerical Python）是数据科学的通用语言，是科学计算、深度学习的基石。为什么是Numpy？实际上Python本身含有列表（list）和数组（array），但对于大数据来说，这些结构是有很多不足的。由于列表的元素可以是任何对象，因此列表中所保存的是对象的指针。例如为了保存一个简单的[1,2,3]，都需要有3个指针和3个整数对象。对于数值运算来说，这种结构显然比较浪费内存和CPU等宝贵资源。至于array对象，它可以直接保存数值，和C语言的一维数组比较类似。但是由于它不支持多维，在上面的函数也不多，因此也不适合做数值运算。Numpy（Numerical Python的简称）的诞生弥补了这些不足。Numpy提供了两种基本的对象：ndarray（N-dimensional Array Object）和ufunc（Universal Function Object）。ndarray是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。\n1. 创建Numpy数组在 Python 内建对象中，数组有三种形式：\n1）列表：[1, 2, 3]2）元组：(1, 2, 3, 4, 5)3）字典：{A:1, B:2}其中，元组与列表相似，不同之处在于元组的元素不能修改。而字典由键和值构成，上例中，A为键，1为值。python 标准类针对数组的处理局限于 1 维，并仅提供少量的功能。而 NumPy 最核心且最重要的一个特性就是其封装了一个新的数据类型ndarray（N-dimensional Array），它是一个多维数组对象。该对象封装了许多常用的数学运算函数，方便我们做数据处理、数据分析等。\n1.1 将列表转换成ndarraynp.array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)\n\nobject：列表、元组等。dtype：数据类型。如果未给出，则类型为被保存对象所需的最小类型。\n\n例：\nimport numpy as nplst = [[3.14, 2.17, 0, 1, 2], [1, 2, 3, 4, 5]]nd = np.array(lst)print(nd1) #[[3.14, 2.17, 0, 1, 2]# [1. 2. 3. 4. 5.]]print(type(nd))#&lt;class &#x27;numpy.ndarray&#x27;&gt;\n1.2 使用random模块生成数组在深度学习中，我们经常需要对一些参数进行初始化，因此为了更有效地训练模型，提高模型的性能，有些初始化还需要满足一定的条件，如满足正态分布或均匀分布等。这里介绍了几种常用的方法，表1列举了np.random模块常用的函数。\n表1 np.random模块常用函数\n\n\n    \n\n\n\n\n例：\nimport numpy as npnp.random.seed(123)nd = np.random.randn(2, 3)print(nd)#[[-1.0856306 0.99734545 0.2829785]#[-1.50629471 -0.57860025 1.65143654]]\n1.3 创建特定形状的多维数组表2 Numpy数组创建函数\n\n\n    \n\n\n1.4利用arange、linspace函数生成数组arange() 的功能是在给定区间内创建一系列均匀间隔的值。方法如下：\nnumpy.arange(start, stop, step, dtype=None)\n\nstart: 序列的起始值。\nstop: 序列的结束值。\nstep: 步长。\n\n例：\n# 在区间 [3, 7) 中以 0.5 为步长新建数组np.arange(3, 7, 0.5, dtype=&#x27;float32&#x27;)# array([3. , 3.5, 4. , 4.5, 5. , 5.5, 6. , 6.5], dtype=float32)\nlinspace 用于在指定的区间内返回间隔均匀的值。其方法如下：\nnumpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)\n\nstart：序列的起始值。stop：序列的结束值。num：生成的样本数。默认值为 50。endpoint：布尔值，如果为真，则最后一个样本包含在序列内。retstep：布尔值，如果为真，返回间距。dtype：数组的类型。\n\n例：\n# 在0～10之间生成等间隔的10个数np.linspace(0, 10, 10, endpoint=True)#array([ 0.        ,  1.11111111,  2.22222222,  3.33333333,  4.44444444,#        5.55555556,  6.66666667,  7.77777778,  8.88888889, 10.        ])\n2. 数组维度和形状NumPy 数组又被称之为 ndarray 多维数组，n 就可以从1维依次递增。下图显示了 1 至 3 维的 NumPy 数组示例。\n\n    \n\n\n图1 1至3维Numpy数组\n\n通过下例了解数组的维度和形状。\none = np.array([7, 2, 9, 10])two = np.array([[5.2, 3.0, 4.5],                [9.1, 0.1, 0.3]])three = np.array([[[1, 1], [1, 1], [1, 1]],                  [[1, 1], [1, 1], [1, 1]],                  [[1, 1], [1, 1], [1, 1]],                  [[1, 1], [1, 1], [1, 1]]])one.shape, two.shape, three.shape#((4,), (2, 3), (4, 3, 2))\n3. Ndarray数组基本操作3.1 类型转换表3 Numpy中的类型转换函数\n\n\n    \n\n\n\na = np.arange(4).reshape(2, 2)np.asmatrix(a)  # 将二维数组转化为矩阵类型输出结果：matrix([[0, 1],        [2, 3]])\n3.2更改数组形状表4 Numpy中改变数组形状的一些函数\n\n\n    \n\n\n\n\n(1) reshape\narr =np.arange(10)print(arr)# 将向量 arr 维度变换为2行5列print(arr.reshape(2, 5))# 指定维度时可以只指定行数或列数, 其他用 -1 代替print(arr.reshape(5, -1))print(arr.reshape(-1, 5))输出结果：[0 1 2 3 4 5 6 7 8 9][[0 1 2 3 4] [5 6 7 8 9]][[0 1] [2 3] [4 5] [6 7] [8 9]][[0 1 2 3 4] [5 6 7 8 9]]\n(2) resize\narr =np.arange(10)print(arr)# 将向量 arr 维度变换为2行5列arr.resize(2, 5)print(arr)输出结果：[0 1 2 3 4 5 6 7 8 9][[0 1 2 3 4] [5 6 7 8 9]]\n(3) T\narr =np.arange(12).reshape(3,4)# 向量 arr 为3行4列print(arr)# 将向量 arr 进行转置为4行3列print(arr.T)输出结果：[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]][[ 0  4  8] [ 1  5  9] [ 2  6 10] [ 3  7 11]]\n(4) ravel\narr =np.arange(6).reshape(2, -1)print(arr)# 按照列优先，展平print(&quot;按照列优先，展平&quot;)print(arr.ravel(&#x27;F&#x27;))# 按照行优先，展平print(&quot;按照行优先，展平&quot;)print(arr.ravel())输出结果：[[0 1 2] [3 4 5]]按照列优先，展平[0 3 1 4 2 5]按照行优先，展平[0 1 2 3 4 5]\n(5) flatten\na =np.floor(10*np.random.random((3,4)))print(a)print(a.flatten())输出结果：[[4. 0. 8. 5.] [1. 0. 4. 8.] [8. 2. 3. 7.]][4. 0. 8. 5. 1. 0. 4. 8. 8. 2. 3. 7.]\n(6)squeeze\n这是一个主要用来降维的函数，把矩阵中含1的维度去掉。\narr =np.arange(3).reshape(3, 1)print(arr.shape)  #(3,1)print(arr.squeeze().shape)  #(3,)arr1 =np.arange(6).reshape(3,1,2,1)print(arr1.shape) #(3, 1, 2, 1)print(arr1.squeeze().shape) #(3, 2)\n(7) transpose\n对高维矩阵进行轴对换，这个在深度学习中经常使用，比如把图片中表示颜色顺序的RGB改为GBR。\narr2 = np.arange(24).reshape(2,3,4)print(arr2.shape)  #(2, 3, 4)print(arr2.transpose(1,2,0).shape)  #(3, 4, 2)\n3.3 合并数组表5 Numpy数组合并方法\n\n\n    \n\n\n\n说明：\n1）append、concatenate以及stack都有一个axis参数，用于控制数组的合并方式是按行还是按列；2）对于append和concatenate，待合并的数组必须有相同的行数或列数（满足一个即可）；3）stack、hstack、dstack，要求待合并的数组必须具有相同的形状（shape）。\n\n(1) append\n合并一维数组：\na =np.array([1, 2, 3])b = np.array([4, 5, 6])c = np.append(a, b)print(c) # [1 2 3 4 5 6]\n合并多维数组：\na =np.arange(4).reshape(2, 2)b = np.arange(4).reshape(2, 2)# 按行合并c = np.append(a, b, axis=0)print(&#x27;按行合并后的结果&#x27;)print(c)print(&#x27;合并后数据维度&#x27;, c.shape)# 按列合并d = np.append(a, b, axis=1)print(&#x27;按列合并后的结果&#x27;)print(d)print(&#x27;合并后数据维度&#x27;, d.shape)输出结果：按行合并后的结果[[0 1] [2 3] [0 1] [2 3]]合并后数据维度 (4, 2)按列合并后的结果[[0 1 0 1] [2 3 2 3]]合并后数据维度 (2, 4)\n(2) concatenate\n沿指定轴连接数组或矩阵：\nimport numpy as npa =np.array([[1, 2], [3, 4]])b = np.array([[5, 6]])c = np.concatenate((a, b), axis=0)print(c)d = np.concatenate((a, b.T), axis=1)print(d)输出结果：[[1 2] [3 4] [5 6]][[1 2 5] [3 4 6]]\n(3) stack\n沿指定轴堆叠数组或矩阵：\na =np.array([[1, 2], [3, 4]])b = np.array([[5, 6], [7, 8]])print(np.stack((a, b), axis=0))输出结果：[[[1 2]  [3 4]] [[5 6]  [7 8]]]\n3.4数组索引和切片NumPy 中的索引和 Python 对list索引的方式非常相似，但又有所不同。\n(1) 数组索引\n一维数组索引\n取一维数据的索引和 list 一样\na = np.arange(10)a[1]输出结果：1\n#分别获取索引值为 1，2，3 的数据a[[1, 2, 3]] # 多加一层 [] 使用逗号隔开输出结果：array([1, 2, 3])\n二维数组索引\n#访问二维Ndarray中的单个元素：a = np.arange(20).reshape(4, 5)a[1, 2] # 不加 []，直接使用逗号隔开输出结果：7\nPython 中 list 索引 2 维数据的方法写法是 a[1][2]，可以看到还是有点区别的。\n访问二维Ndarray中的多个元素：a[[1, 2], [3, 4]]输出结果：array([8, 14])\n这里需要注意索引的对应关系。我们实际获取的是[1, 3]，也就是第2行和第4列对于的值8。以及[2, 4]，也就是第3行和第5列对应的值14。\n(2) 数组切片\nNumPy里面针对 Ndarray 的数组切片和Python里的list切片操作是一样的。其语法为：\n\nNdarray [start : stop : step]\n\n[start:stop:step] 分别代表 [起始索引:截至索引:步长]。\n一维数组切片\na = np.arange(10)a[:5] # 默认左边从 0 开始，左闭右开a[5:] # 默认右边以最后一个结尾a[0:10:2] # 步长为2输出结果：array([0, 1, 2, 3, 4])array([5, 6, 7, 8, 9])array([0, 2, 4, 6, 8])\n多维数组切片\na = np.arange(20).reshape(4, 5)a[0:3, 2:4] #先取第 1，2，3 行（第一个维度），再取第 3，4 列（第二个维度）输出结果：array([[ 2,  3],       [ 7,  8],       [12, 13]])\n3.5 搜索和计数表6 Numpy搜索和计数函数\n\n\n    \n\n\na = np.random.randint(0, 10, 20) # 在 [0,10) 之间生成 20 个随机数anp.argmax(a)np.nonzero(a)np.count_nonzero(a)输出结果：array([9, 2, 0, 5, 2, 4, 2, 0, 0, 0, 0, 7, 3, 6, 8, 1, 9, 1, 0, 3])0(array([ 0,  1,  3,  4,  5,  6, 11, 12, 13, 14, 15, 16, 17, 19]),)14\n4. 通用函数Numpy提供了两种基本的对象，即ndarray和ufunc对象。前文已经介绍了ndarray，本节将介绍Numpy的另一个对象通用函数（ufunc）。ufunc是universal function的缩写，它是一种能对数组的每个元素进行操作的函数。许多ufunc函数都是用C语言级别实现的，因此它们的计算速度非常快。此外，它们比math模块中的函数更灵活。math模块的输入一般是标量，但Numpy中的函数可以是向量或矩阵，而利用向量或矩阵可以避免使用循环语句，这点在机器学习、深度学习中非常重要。\n表7 Numpy中的几个常用通用函数\n\n\n    \n\n\n5. 广播机制Numpy的Universal functions中要求输入的数组shape是一致的，当数组的shape不相等时，则会使用广播机制。不过，调整数组使得shape一样，需要满足一定的规则，否则将出错。这些规则可归纳为以下4条。\n\n1）让所有输入数组都向其中shape最长的数组看齐，不足的部分则通过在前面加1补齐，如：a：2×3×2b：3×2则b向a看齐，在b的前面加1，变为：1×3×22）输出数组的shape是输入数组shape的各个轴上的最大值；3）如果输入数组的某个轴和输出数组的对应轴的长度相同或者某个轴的长度为1时，这个数组能被用来计算，否则出错；4）当输入数组的某个轴的长度为1时，沿着此轴运算时都用（或复制）此轴上的第一组值。\n\n广播在整个Numpy中用于决定如何处理形状迥异的数组，涉及的算术运算包括（+，-，*，/…）。这些规则说得很严谨，但不直观，下面我们结合图形与代码来进一步说明。  目的：A+B，其中A为4×1矩阵，B为一维向量（3,）。要相加，需要做如下处理：  ·根据规则1，B需要向看齐，把B变为（1,3）  ·根据规则2，输出的结果为各个轴上的最大值，即输出结果应该为（4,3）矩阵，那么A如何由（4,1）变为（4,3）矩阵？B又如何由（1,3）变为（4,3）矩阵？  ·根据规则4，用此轴上的第一组值（要主要区分是哪个轴），进行复制（但在实际处理中不是真正复制，否则太耗内存，而是采用其他对象如ogrid对象，进行网格处理）即可，详细处理过程如图2所示。\n\n    \n\n\n图2 Numpy广播规则示意图\n\nA = np.arange(0, 40,10).reshape(4, 1)B = np.arange(0, 3)print(&quot;A矩阵的形状:&#123;&#125;,B矩阵的形状:&#123;&#125;&quot;.format(A.shape,B.shape))C=A+Bprint(&quot;C矩阵的形状:&#123;&#125;&quot;.format(C.shape))print(C)运行结果：A矩阵的形状:(4, 1),B矩阵的形状:(3,)C矩阵的形状:(4, 3)[[ 0  1  2] [10 11 12] [20 21 22] [30 31 32]]\n附录：dtype 数据类型\n    \n\n\n\n\n\n更多Numpy相关内容，请查看：http://www.Numpy.org/\n\n","categories":["Learning Materials"]},{"title":"Topic1：Is Accurate and Light-weight DNN Multi-layer Latency Prediction Possible?","url":"/2022/10/22/Topic1/","content":"\n\n\n    \n    \n    \n        .head{\n            position: relative;\n            padding: 0px;\n\n        }\n        .bl1{\n            width: 94%;\n            height: 220px;\n            box-shadow: 0 4px 8px 0 #1D2088;\n            font-size: 20px;\n            text-align: left;\n            background-color: #fff;\n            border-radius: 7px;\n            position: relative;\n            margin: 0px;\n            padding: 20px;\n            line-height: 1.5em;\n            text-decoration: none;\n        }\n\n        .button {\n          display: inline-block;\n          padding: 5px 10px;\n          font-size: 14px;\n          cursor: pointer;\n          text-align: center;   \n          text-decoration: none;\n          outline: none;\n          color: #000000;\n          background-color: #ffffff;\n          border: 2px solid #008cba;\n          border-radius: 8px;\n          box-shadow: 0  #1D2088;\n        }\n        .button2 {\n          display: inline-block;\n          padding: 10px 20px;\n          font-size: 14px;\n          cursor: pointer;\n          text-align: center;   \n          text-decoration: none;\n          outline: none;\n          color: #000000;\n          background-color: #ffffff;\n          border: 2px solid #008cba;\n          border-radius: 8px;\n          box-shadow: 0 4px 8px #1D2088;\n        }\n        .button:hover {background-color: #B4C7EE}\n\n        .button:active {\n          background-color: #ffffff;\n          box-shadow: 0 3px #1D2088;\n          transform: translateY(2px);\n        }\n\n        .bl2{\n            width: 94%;\n            height: 250px;\n            box-shadow: 0 4px 8px 0 #1D2088;\n            font-size: 20px;\n            text-align: left;\n            background-color: #fff;\n            border-radius: 7px;\n            position: relative;\n            line-height: 1.5em;\n            margin: 0px;\n            padding: 20px;\n        }\n\n        .bl3{\n            width: 94%;\n            height: 280px;\n            box-shadow: 0 4px 8px 0 #1D2088;\n            font-size: 20px;\n            text-align: left;\n            background-color: #fff;\n            border-radius: 7px;\n            position: relative;\n            margin: 0px;\n            padding: 20px;\n            line-height: 1.5em;\n            text-decoration: none;\n        }\n\n        .bl4{\n            width: 94%;\n            height: 250px;\n            box-shadow: 0 4px 8px 0 #1D2088;\n            font-size: 20px;\n            text-align: left;\n            background-color: #fff;\n            border-radius: 7px;\n            position: relative;\n            margin: 0px;\n            padding: 20px;\n            line-height: 1.5em;\n            text-decoration: none;\n        }\n        p {font-size: 14px;}\n\n        a { text-decoration: none} \n        a: hover{ text-decoration: none}\n    \n\n\n    \n        \n        \n    \n    \n        CoDL：Efficient CPU-GPU Co-execution for Deep Learning Inference on Mobile Devices\n        \n        本文提出了一个在移动设备的CPU和GPU上协同执行模型推理的系统架构和方法，许多方法的提出基于作者对大量实验现象的观察。通过联系实验现象和系统基本特性，该文实现了针对于移动设备的准确且轻量的时延预测。同时，该文数据分割和算子链的设计也具有启发意义。\n\n        \n        Paper Note\n        &nbsp\n        \n        Paper Link\n    \n    \n    \n        Neurosurgeon：Collaborative Intelligence Between the Cloud and Mobile Edge\n        \n        1）性能预测器准确度无法保证。该系统的性能预测器仅仅针对对不同层参数构建简单的线性或指数回归模型，虽然该模型执行很快，但如此简单的预测方法难以获得高预测精度，而较低的预测精度势必影响DNN分割算法的效果；\n\n2）对多层网络的性能预测不准确。该文仅使用每层网络时延和能耗的加和表示多层的性能，而实验表明运行多层网络的时延和能耗往往低于每层网络的加和，由错误的性能预测数据确定DNN分割点很难得到最优方案。\n\n        \n        Paper Note\n        &nbsp\n        \n        Paper Link\n    \n\n    \n    \n        µLayer：Low Latency On-Device Inference Using Cooperative Single-Layer Acceleration and Processor-Friendly Quantization\n        \n        该文致力于通过CPU-GPU协同执行的方式进行高效神经网络推理，设计了一种层级协同推理方法，能够取得一定的性能提升，但仍存在一些问题：\n        1）该系统中的时延预测器采用机器学习拟合函数，与Neurosurgeon相同，存在精度低的问题；\n\n2）该CPU-GPU协同方法是层粒度的，存在高频同步的问题，而由于时延预测器的不准确性会造成CPU，GPU的运行差异，同步开销可能会成为时延的主体部分。\n\n        \n        Paper Note\n        &nbsp\n        \n        Paper Link\n    \n\n    \n    \n        NeuralPower：Predict and Deploy Energy-Efficient Convolutional Neural Networks\n        \n        1）该文考虑到其他基于单网络复杂度指标（e.g. FLOPs）方法的局限性，该文提出基于多项式模型的模型性能预测方法；\n\n2）该文不仅进行了模型运行时延预测，还设计了能耗的预测方法；\n\n3）该文的完整模型时延预测是对各层时延的加和，实验发现各层运行时延的加和与完整模型运行时延相近，该说法是否可靠还待考究。\n\n        \n        Paper Note\n        &nbsp\n        \n        Paper Link\n    \n\n\n","categories":["Topic Corner"]},{"title":"µLayer：Low Latency On-Device Inference Using Cooperative Single-Layer Acceleration and Processor-Friendly Quantization","url":"/2022/10/20/%CE%BCLayer/","content":"\n 来        源：EuroSys ‘19: Proceedings of the Fourteenth EuroSys Conference 2019 - March 2019 - Article No.: 45 - Pages 1–15 https://doi.org/10.1145/3302424.3303950\n原文速递：µLayer: Low Latency On-Device Inference Using Cooperative Single-Layer Acceleration and Processor-Friendly Quantization\n\n1. Background &amp; Motivation随着神经网络（NN）的发展，移动服务供应商在移动设备上部署了许多服务，比如Google的手写转文字功能、Google的即时翻译、YouTube的视频分割以及Google、Apple等公司的虚拟助手。而为满足这些应用的时延要求，传统的做法是依赖于丰富的云端资源实现的。然而，随着高性能的移动端SoC的出现，完全依赖移动端设备进行神经网络推理成为可能。由于强响应性对移动服务至关重要，高效利用移动设备资源是十分必要的。\n通过更好地利用移动设备硬件资源，对轻量神经网络的几乎实时响应成为可能，但由于时延问题，大部分移动服务仍然依赖云端资源，比如所有实际的虚拟助手都将工作卸载到云端进行语音识别。而现在的Soc上具有多种资源，实现快速准确的设备上推理是可行的。\n2. Contributions\n1）发现协同实现神经网络单层加速的潜力。该文发现现代SoC上的CPU和GPU具有平衡的吞吐量，使CPU-GPU协同神经网络加速成为可能；\n2）提出新的协同单层加速机制。通过从多维度对神经网络执行进行优化，获得相比先进方法的时延降低；\n3）设计μLayer系统。提出一个优化的神经网络架构μLayer用于减小神经网络的执行时延。\n\n3. Design Details3.1 协同单层加速如图1(a)、(b)所示，现有移动神经网络框架由于只利用单一处理器限制了性能，而本文提出的框架能够在CPU和GPU上协同执行神经网络中的层。\n\n    \n\n\n图1 设备上推理机制对比\n\n该文提出通道级工作负载分配方法如图2所示，其可以避免引入CPU和GPU间的冗余计算。\n\n    \n\n\n图2 一层的通道级工作负载分配\n\n对于卷积层和全连接层，filter被以p:(1-p)的比例分配给各处理器，完整的输入数据将被分配给各处理器进行计算，最后计算出的输出通道被合并生成输出数据。对于池化层，输入数据被分配给各处理器，每个处理器对自己的数据部分使用全局函数进行计算，最后的结果将被合并。\n3.2 针对处理器的量化为了优化每个处理器的性能表现，该文考虑了2种量化方案：16位半精度浮点数（F16）和8位线性量化（QUInt8）。因为GPU在实现高吞吐量的浮点运算方面有本地硬件支持，对GPU使用16位半精度浮点数量化。CPU更擅长处理QUInt8类型的数据，因此对其使用8位线性量化。\n3.3 分支分配现有的一些神经网络（如GoogLeNet）包含分支结构，如图3。这些分支可能会影响通道级工作负载分配的性能。而多分支结构的时延可通过并行运行多个分支来隐藏，即同一分支上的多个层将在一个处理器上运行。\n\n    \n\n\n图3 多分支结构神经网络示例\n\n3.4 μLayer运行时架构如图4，μLayer由3个部件组成：一个神经网络分割器、一个时延预测器和一个神经网络执行器。\n\n    \n\n\n图4 μLayer运行时架构\n\n神经网络分割器负责协同执行计划的生成，对于每一层，神经网络分割器决定通道分割的比例p(0\\leq p \\leq 1)，神经网络分割器根据时延预测器找出最优的p值。\n时延预测器能够根据每层神经网络的参数（如输入尺寸和filter尺寸）以及p值预测该层的执行时延。该文在Neurosurgeon(Paper Link)设计的时延预测器基础上引入参数p，首先对CPU和GPU独立执行运用指数回归方法拟合模型，然后通过给定的p值调整时延预测值。时延预测器将时延预测值反馈给神经网络分割器选出分割方案，最后神经网络执行器根据最优分割方案在CPU和GPU间协同进行神经网络推理。\n4. Comments该文致力于通过CPU-GPU协同执行的方式进行高效神经网络推理，设计了一种层级协同推理方法，能够取得一定的性能提升，但仍存在一些问题：\n\n1）该系统中的时延预测器采用机器学习拟合函数，与Neurosurgeon相同，存在精度低的问题；\n2）该CPU-GPU协同方法是层粒度的，存在高频同步的问题，而由于时延预测器的不准确性会造成CPU，GPU的运行差异，同步开销可能会成为时延的主体部分。\n\n","categories":["Paper Notes"]},{"title":"深度学习方法探析——卷积神经网络","url":"/2022/10/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E6%9E%90%E2%80%94%E2%80%94%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"1. 卷积神经网络的组成1.1 卷积 (Convolution)1.1.1 卷积运算在数字图像处理中，我们用到了一种边缘检测算子，图1为一种垂直边缘检测的过程。依次在图像上圈出9个单元，将检测算子中的每个对应单元与圈出的单元相乘，最后将所有乘积结果相加，作为一个输出。依次移动框选区域，直至对整个图像进行运算。从输出图像可以看出，该运算过程检测出了图像中的垂直边缘，这个运算的过程就可以理解为卷积神经网络中最基本的卷积运算。使用不同的算子可以对图像中的不同边缘进行检测，甚至是45°、75°等特殊边缘，在边缘检测领域也曾提出过Sobel、Scharr等算子，其性能根据应用场景有所差别。\n\n    \n\n\n图1 数字图像处理中垂直边缘检测过程\n\n卷积神经网络中的卷积运算，与上述操作的不同之处在于：卷积神经网络将算子中的9个固定的值当做9个参数来进行训练，如此便能得到任一种需要的算子，而不是只有固定的一种。卷积神经网络通常将这个算子称为过滤器，或卷积核。\n1.1.2 Padding如果我们有一个n×n的图像，使用f×f的过滤器进行卷积，得到的输出图像维度为(n-f+1)×(n-f+1)。图1中的例子是对6×6的图像使用3×3的过滤器进行卷积，得到了4×4的输出。这会导致两个缺点：1）每次对图像进行卷积操作后，图像都会缩小；2）图像边缘的像素只在少数卷积运算中被使用，这导致了图像边缘的许多信息丢失。为了解决这些缺点，Padding操作在图像的边缘填充一些数据，此时，输出的图像维度变为(n+2p-f+1)×(n+2p-f+1)，其中，p为padding操作增加的层数。例如，在图1中的原始图像上加上1层数据，变为8×8的图像，经过卷积运算后，输出为6×6的图像，与原始图像大小相同。Padding操作通常有两种选择：Valid卷积和Same卷积。Valid卷积指不对原始图像进行填充，输出维度为(n-f+1)×(n-f+1)的图像；Same卷积指对图像进行填充，输出维度为(n+2p-f+1)×(n+2p-f+1)的图像，并使其与原始图像大小相等。\n1.1.3 卷积步长在进行卷积操作时，还有一个重要的参数要进行选择：卷积步长(stride)。卷积步长指过滤器每次在图像上移动的格数。设置卷积步长后，输出的图像维度为\\lfloor\\frac{n+2p-f}{s}+1\\rfloor\\times\\lfloor\\frac{n+2p-f}{s}+1\\rfloor ，其中，s为卷积的步长。\n1.1.4 三维卷积彩色图像有R、G、B三个通道，它的维度不再是之前二维的n×n，变为三维的n×n×3，之前的卷积操作也应相应地变为三维卷积。三维卷积采用一与原图像通道数相同的三维过滤器进行卷积，如图2所示。\n\n    \n\n\n图2 三维卷积过程\n\n三维卷积的过程为：将三维过滤器与原图像进行逐层二维卷积，并将得到的三层数据按位置相加，得到最终的二维输出。可能有一个过滤器是用来检测水平边缘的，但还想同时检测图像的其他特征。这时就可以增加过滤器的数量，每个过滤器负责检测一个特征，如图3所示，最终输出的通道数与过滤器的个数相等。也就是说，要检测多少特征，就会有多少个通道输出。\n\n    \n\n\n图3 多特征三维卷积\n\n1.1.5 卷积网络单层卷积神经网络的前向传播过程如图4所示，可与普通的神经网络前项传播类比。卷积操作可以看做原来的特征权重W所做的操作，对每个滤波器卷积后得到的输出加上相应的偏差b后，通过一个非线性激活函数g(z)输出。\n\n    \n\n\n图4 卷积神经网络前向传播过程\n\n现将卷积神经网络中l层各阶段的维度总结到表1中。\n表1 卷积神经网络l层各阶段的维度\n\n\n    \n\n\n其中，n_H^{[l]}=\\lfloor\\frac{n_H^{[l-1]}+2p^{[l]}-f^{l}}{s^{[l]}}+1\\rfloor,n_H^{[l]}=\\lfloor\\frac{n_W^{[l-1]}+2p^{[l]}-f^{l}}{s^{[l]}}+1\\rfloor。若有m个数据输入，则输出A^{[l]}的维度为m\\times n_H^{[l]}\\times n_W^{[l]}\\times n_C^{[l]} 。\n1.1.6 卷积的优势与普通神经网络相比，采用卷积的神经网络主要有两个优势：参数共享和稀疏连接。1) 参数共享在使用普通的神经网络处理大量的特征时，由于两层的节点全部紧密相连，特征矩阵W中的参数个数为两层节点数的乘积，这可能有上千万的数量级。而使用卷积运算，无论前后两层有多少数据，需要训练的参数都只有过滤器的大小。这是由于，一个特征检测器如果适用于图片的某个区域，那么它也可能适用其他区域，而不需要额外训练其他特征检测器，做到参数的共享。2) 稀疏连接稀疏连接指每个输出都只与过滤器包含的范围有关，而与其他输入特征无关。神经网络通过参数共享和稀疏连接两种机制减少参数，以此预防过拟合。同时，这使得卷积神经网络具有平移不变的属性。即使图像移动了几个像素，但其仍然有相似的特征，通过参数共享可以获得同样的输出标记，从而增强网络的鲁棒性。\n1.2 池化 (Pooling)卷积神经网络除了有卷积层外，通常还使用池化层来缩减模型的大小，提高计算速度，同时提高所提取特征的鲁棒性。池化操作通常可分为两种类型：最大池化和平均池化。池化操作和卷积操作类似，可以使用一个过滤器，根据设定的步长和padding值对原图像进行运算。最大池化进行的操作是将该过滤器范围内的数据最大值进行输出，平均池化进行的操作是对过滤器范围内的数据求平均值作为输出。对最大池化可以如下理解：若在图像的某个区域检测到了某个特征，池化输出在该部分会有一个较大的值。虽然，池化层作为卷积神经网络的一部分，但它没有任何需要调整的参数，一旦设定好f和s，其就是一个固定操作。池化的常用参数为f = s = 2，这可以使上一层的长和宽都减小一倍。\n1.3 全连接层 (Fully Connected)全连接层的操作如图5所示，FC1将前面卷积池化后得到的数据进行展平，之后就与普通的深层神经网络相同，通过参数W和b进行前向传播，最后通过softmax层或sigmoid函数输出。由于两个全连接层中的节点紧密相连，这就是所谓的“全连接”。\n\n    \n\n\n图5 全连接层\n\n2. 经典卷积神经网络2.1 LeNet-5LeNet-5是在1998年被提出的，一个LeNet的示例如图6所示。由于LeNet提出时主要用于处理灰度图像，这里采用一32×32×1的图像作为输入。LeNet的网络形式为：先卷积层和池化层交替，最后由几个全连接层输出预测结果。\n\n    \n\n\n图6 LeNet-5示例\n\n2.2 Alexnet在一张227×227像素的图片上采用Alexnet网络的示例如7所示。Alexnet和LeNet非常相似，但Alexnet要大得多，LeNet有大约6万个参数，AlexNet包含约6000万个参数。因此，Alexnet表现得比LeNet更出色。\n\n    \n\n\n图7 Alexnet示例\n\n2.3 VGG-16VGG-16是一种专注于构建卷积层的网络，它的一大优点是简化了神经网络结构，其示例如图8所示。VGG-16中的16指在这个网络中共包含16个卷积层和全连接层，虽然它规模很大，包含约1.38亿个参数，但其具有相当规整的结构：几个卷积层后接一个池化层，并且每次卷积的过滤器数量成倍增长，每次池化操作都将图像的大小缩减一倍。随着网络的加深，图像大小逐渐减小，深度逐渐增加。\n\n    \n\n\n图8 VGG-16示例\n\n3. 先进的卷积神经网络结构3.1 ResNetResNet全称为Residual Networks，意为残差网络。ResNet是由残差块组成的网络，一个残差块如图9所示，残差块将a^{[l]}跨过计算a^{[l+1]}送至下一层，此时，a^{[l+2]}就变成\n\n    \n\n\n\n    \n\n\n图9 残差块\n\n普通网络（Plain Network）在比较深时可能会出现梯度消失和梯度爆炸的问题，影响网络的性能，而残差网络可以很好地应对深度较大的网络，残差网络所做的事就是将浅层的信息传递到更深层的网络中去，可能远比一两层多。当网络层数很多时，如果为了应对梯度消失和梯度爆炸，对网络使用正则化，在深层的W^{[l]}会十分接近0，为了方便起见，b^{[l]}设为0，将(1)式展开为\n\n    \n\n\n在很深的层l+2上，将W^{[l+2]}当做0看待，(2)式变为\n\n    \n\n\n其中，由于激活函数采用ReLu，故经过激活函数后得到a^{[l]}，实现了信息从浅层到深层的传递，因此，可以训练更深层的网络，而不降低网络的效率。值得注意的是，残差网络因为采用网络的跳跃连接，为了保证维度合适，采用了很多same卷积。\n3.2 Google Inception网络在构建卷积神经网络时，我们常常需要决定很多超参数，比如过滤器的大小、是否需要池化层等等。Inception网络所做的事就是，让网络代替人去做这些选择，虽然网络变得复杂，但网络表现可以得到提高。Inception模块如图10所示，它将多种操作得到的结果堆叠起来，为了保证维度相符，全部采用same卷积。\n\n    \n\n\n图10 Inception模块\n\n这里采用了一种1×1的卷积形式，现对其进行分析。对一28×28×192的输入数据直接应用5×5的same卷积，如图11(a)所示。其总共要进行28×28×32×5×5×192≈1.2亿次乘法运算。\n\n    \n\n\n图11 有无瓶颈层卷积对比\n\n图11(b)为采用了瓶颈层的卷积，第一次卷积操作进行了28×28×16×192≈240万次乘法运算，第二次卷积操作进行了28×28×32×5×5×16≈1000万次乘法运算，加起来共约1240万，仅为原来的十分之一。采用1×1卷积的原因，我认为是1×1卷积不会对原图像的特征起到影响，但却起到了压缩规模的作用，通过后续的卷积运算还可以保持原来的效果。将许多Inception模块组合起来就形成了GoogLeNet网络，如图12所示。网络中存在一些分支，它们起到一些调整的作用，使隐藏层也参与特征计算，防止网络发生过拟合。\n\n    \n\n\n图12 GoogLeNet网络\n\n4. 目标检测4.1 目标定位目标分类只需要输出一个预测值即可，但目标定位不仅要完成分类，还要确定目标在图像中的位置，并标记出来，如图13所示。\n\n    \n\n\n图13 目标定位\n\n目标分类只需要softmax层输出每个类别的概率即可，目标定位问题需要对该层的输出进行更改，增加一些辅助定位的参数，修改后的输出为\n\n    \n\n\n其中，p_c用来标记图片中是否包含要检测的对象，b_x、b_y表示目标的中心点坐标，b_h、b_w表示目标的高度和宽度，c为目标的类别，0表示未检测到该目标。当p_c为1时，代价函数将所有参数考虑进去；当p_c为0时，仅考虑p_c的准确度。\n4.2 基于滑动窗口的目标检测比较简单的滑动窗口目标检测过程为：选择一种大小的窗口放在图像的初始位置，裁切下窗口中的图片，送入卷积神经网络中进行预测。依次移动滑动窗口，直至遍历整张图片。然后再改变窗口大小，重复上述过程，总有一个窗口可以识别到目标。但这种方法滑动窗口很慢，并且运算量巨大。为了解决这一问题，可以使用滑动窗口的卷积实现。首先，需要将卷积神经网络中的所有层都转化为卷积操作，也就是要将全连接层转化为卷积层，图14 (a)为一个卷积层转化为全连接层的过程，将其转化为卷积层只需采用大小相同的过滤器对其进行卷积操作，得到1×1的维度，如图14 (b)所示。\n\n    \n\n\n图14 全连接层转化为卷积层\n\n假设一个模型的滑动窗口大小为14×14×3，每次滑动窗口裁切后进行运算的过程如图15 (a)所示。在如图15(b)所示的16×16图片运用14×14的窗口进行卷积运算要进行4次，可以发现产生了许多重复的计算。滑动窗口的卷积实现直接对16×16×3的图片应用原卷积操作，第一个滑动窗口涉及到的计算区域在图15(b)中用绿色标出，可以看到，对第一个滑动窗口的运算只体现在了输出的2×2×4模块的左上角。同理，其余三次运算体现为另外三个角落上。因此，只需对原图进行一次卷积神经运算就可以得到运算4次滑动窗口的效果，减少了很多运算。\n\n    \n\n\n(a)对滑动窗口大小区域运行卷积神经网络\n\n\n    \n\n\n(b)滑动窗口的卷积实现\n\n图15 普通滑动窗口和滑动窗口的卷积实现\n\n\n\n4.3 YOLO (You Only Look Once)算法4.3.1 Bounding Box预测采用滑动窗口的目标检测虽然能够检测到目标，但那些边框没办法完美匹配目标的位置。Bounding Box预测是YOLO算法中用于目标分类和定位的方法，它可以精确预测目标的位置。如图16所示，Bounding Box将图片分割成若干部分，每个部分对应一个与(4)式相同的label，图中的输出为9×9×k (k为单个label的长度)。在训练时，喂给卷积神经网络图像，并将对应的label作为监督学习目标进行学习，目标仅属于中心点所在的格子。由于采用了滑动窗口的卷积实现，不用对每个格子单独进行一次运算，而是对整张图片进行一次卷积就可以输出所有预测值，减少了计算量，使得YOLO可以用于实时目标检测。\n\n    \n\n\n图16 Bounding Box预测\n\n4.3.2 非极大值抑制 (Non-Max Suppression)当运行目标检测算法时，可能目标位于不同格子中的部分被各格子识别为中心点在其中，这将导致一个目标的多次识别，非极大值抑制做的就是防止目标的多次识别。它首先找出概率最大的矩形，视其为检测到目标，然后将与其交并比较大的矩形抑制掉。然后再找剩下概率最大的矩形，抑制掉与其交并比大的矩形，如此重复，直到遍历所有矩形。\n4.3.3 Anchor Boxes前述操作只能在每个格子里检测一个目标，但如图17所示的情况会出现多个目标归属于同一格的情况，使用Anchor Boxes可以实现在一个格子里检测多个目标。\n\n    \n\n\n图17 一格包含多个目标示意\n\n\n    \n\n\n图18 Anchor boxes\n\nAnchor boxes的思路是这样的：在图17的情况中，我们可以预先设定两个Anchor boxes，如图18所示，实际情况可能需要设定更多的Anchor boxes。这种情况下输出的label就不能和 (4)式相同了，应更改为\n\n    \n\n\n其将 (4)式重复了2遍，如果设定更多Anchor boxes，则需要重复更多次数。在训练时，需要将目标分配到所在格子内与之交并比更大的Anchor box项内，每个Anchor box项应是独立的，不受其他项的影响。YOLO算法的流程为：使用卷积神经网络对图像进行推理后，每个格子里都会得到与Anchor boxes数量相等的项。我们需要先去除神经网络预测不存在对象的格子中的方框，此时剩下的方框中的多个Anchor boxes项可能都会识别到同一目标，再对剩下的格子应用非极大值抑制，得到真正的目标位置。\n","categories":["Learning Materials"]},{"title":"深度学习方法探析——优化算法","url":"/2022/10/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E6%9E%90%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/","content":"1.引言深层学习在应用于大量数据时需要花费大量的训练时间，这成为了阻碍深度学习发展的一个困难。本文总结了几种可以加速深度学习模型训练过程的优化算法，采用Mini-batch优化算法可以有效缓解迭代缓慢的问题，在部分数据处理的过程中持续更新参数；Momentum算法、RMSprop算法和Adam算法能够加速梯度的下降过程，减小梯度在不必要方向上的抖动。\n2. Mini-batch梯度下降法之前我们在反向传播中所用的梯度下降算法，称为batch梯度下降法，在每次计算完毕所有样本对应的dW和db后，再将W和b的值进行更新。这对于数据量小的数据集没有问题，应用向量化的方式也可以很快地进行迭代，但当数据量巨大时，对每个矩阵的处理时间同样是巨大的，这意味着经过很长一段时间才能进行一次梯度下降，这会严重影响模型训练的速度。Mini-batch的方法将很大的数据集分解为多个子训练集，如图1所示，将原来的大数据集随机打乱排序，再划分为具有相同数据量的子集，以保证数据的均匀性，本文将第t个子集表示为X^{\\{t\\}}，对应的标签为Y^{\\{t\\}}。\n\n    \n\n\n图1 mini-batch子集划分\n\nMini-batch方法对每个子集逐一进行梯度下降，每将所有子集遍历一次称为一代(epoch)，与原来的batch方法相比，mini-batch梯度下降法的梯度下降更新参数次数提高了子集数倍数，梯度下降算法也能更快执行。Mini-batch梯度下降法的代价函数随迭代次数的变化与batch法是不同的，图2为某测试数据集，分别对其使用mini-batch和batch梯度下降，得到的总代价曲线如图3所示（本文中的程序均使用3层模型，1到3层的节点数分别为5、2、1）。可以看到，mini-batch梯度下降法在梯度下降的过程中存在很多类似噪声的起伏，但总体趋势还是下降的；batch梯度下降法的总代价函数在学习率适中的情况下可以单调下降。经过相同的迭代次数，mini-batch梯度下降算法得到的总代价更小，说明与batch梯度下降法相比，mini-batch在未完整遍历整个训练集时就开始不断梯度下降更新参数，具有更快的训练速度。\n\n    \n\n\n图2 训练数据集\n\n\n    \n\n\n图3 mini-batch梯度下降法和batch梯度下降法总代价随迭代次数的变化\n\n对Mini-batch梯度下降法得到的模型采用不同的颜色进行分割得到图4，对训练集的准确率如图5所示，为79.67%。\n\n    \n\n\n图4 mini-batch梯度下降法得到的模型\n\n\n    \n\n\n图5 mini-batch模型对训练集的准确度\n\n上文中出现的总代价抖动的情况是由于每次训练的数据子集不同，会存在某些数据子集将模型的训练偏离总代价小的方向，而batch梯度下降法每次训练的数据集相同，总代价不会向着增大的方向移动，但mini-batch梯度下降法能更持续地靠近最小值的方向，使用三维图形表示如图7所示。因此，mini-batch梯度下降法不会使最终代价收敛到某一点上，而是在最优点附近。\n\n    \n\n\n图7 mini-batch和batch梯度下降法在梯度下降过程示意\n\nMini-batch梯度下降法的优点是能更持续地优化模型，但每个子集分割得越小，向量化带来的速度增益就消失得越严重。当每个子集为1个数据时，就完全失去了向量化的加速。因此，合理地选择mini-batch子集的大小是十分重要的。\n3. Momentum梯度下降法3.1 指数加权平均指数加权平均在统计中也叫指数加权移动平均，可以用于对数据进行平滑，可总结为方程\n\n    \n\n\n其中，v_t为t时刻指数加权平均后的值，\\theta_t为t时刻的原始数据，\\beta为权重系数，\\beta越小，平均的数据范围越大。图8为用指数加权平均进行平滑的示意图，各曲线按\\beta从小到大排序为黄、蓝、紫、红，当权重较小时，只对小范围数据进行了平滑，所以数据抖动明显，当权重较大时，红色曲线与理想曲线有一定的偏移，这是由于平滑了过多的数据。因此，合理选择权重可以做到对抖动数据的有效平滑，而权重过小会导致数据的偏移。\n\n    \n\n\n图8 不同权重系数的指数加权平均\n\n3.2 指数加权平均的偏差修正在指数加权的初始阶段，v_0被设置为0。经过第一次运算v_1=\\beta v_0+(1-\\beta)\\theta_1后，v_1仅为\\theta_1的1-\\beta倍，这会比真实值相差很多，因为一般\\beta会取得很大。为了修正这个偏差，可以将v_t修改为\\frac{v_t}{1-\\beta^t}，当t很小时，可以有效弥补指数加权的偏差。而当t很大时， 就接近于1，基本不会产生效果，这使得修正后的值与真实值很相近。当然，如果不关注初始训练时的偏差，也可以不做任何处理，等过了初始阶段就会有比较准确的数据。\n3.3 Momentum梯度下降法Momentum梯度下降法可以加速学习的过程，其思想为：对梯度进行指数加权平均，并利用指数加权平均后的梯度更新权重。算法流程如下：\n\n    \n\n\n假设有一代价函数如图9所示，由于是一椭圆状，绿色箭头表示的梯度下降过程呈抖动下降的趋势。这种情况下的梯度下降只能采用较小的学习率，如果学习率过大会使结果偏离函数的范围，这会导致学习速度缓慢。\n\n    \n\n\n图9 某一代价函数的梯度下降\n\n当对梯度进行指数加权平均后，纵轴上的方向相反的梯度相互抵消使得平均值很小，而指向最优点的横轴方向由于梯度方向一致，仍会有一个较大的平均值。因此，该情况下可以使用较大的学习率进行梯度下降，加速了学习的过程。另外，人们经常将 的值设置为0.9，实践表明该数值具有很好的鲁棒性。\n3.4 编程实现Momentum梯度下降采用Momentum算法对相同数据集采用mini-batch的方法进行训练，得到的模型用颜色进行分割如图10所示，对训练集的准确度如图11所示，为79.67%。\n\n    \n\n\n图10 Momentum梯度下降法得到的模型\n\n\n    \n\n\n图11 Momentum模型对训练集的准确度\n\n这和单纯用mini-batch梯度下降法进行计算得到的结果相同，原因在于该模型过于简单，momentum梯度下降法在训练过程中没有起到过多作用，但当模型很复杂时，就可以看出差别。\n4.RMSprop算法RMSprop算法的全称是Root Mean Square Prop，意为采用均方根的方式加快学习进程。其算法流程如下：\n\n    \n\n\n该算法仍可采用上节的例子进行理解，S_{dW}、S_{db}分别对dW、db的平方进行指数加权平均。当某一维度存在震荡时，其导数会很大，计算得到的S值也会很大，使得对该维度的更新更慢；当指向最低代价的维度出现梯度下降慢的情况时，其导数会较小，相应的S值也会更小，该维度更新得就会加快，缓解了学习的瓶颈。该算法中的\\beta值推荐使用0.999，算法中用到的\\varepsilon主要是为了防止0成为分母导致程序出错，一般使用10^{-8}即可。\n5. Adam优化算法Adam算法可以简单理解为是将Momentum算法和RMSprop算法结合起来的优化算法，其算法流程如下：\n\n    \n\n\n可以看到，Adam算法既对dW和db进行了指数加权平均以减轻抖动，又对他们进行了均方根的运算以缓解梯度下降过程中的瓶颈。另外，运用Adam算法时一般会进行偏差修正，所以对v_{dW}、v_{db}、S_{dW}、S_{db} 都进行了\\frac {1}{1-\\beta}的偏差修正。这里，根据Momentum梯度下降算法和RMSprop算法的内容对不同的\\beta进行了角标区分，\\beta_1取0.9，\\beta_2取0.999，\\varepsilon取10^{-8}。仍采用上面章节中使用的模型和数据集，得到的总代价随代数变化的曲线如图12所示，对训练得到的模型按照颜色进行划分如图13所示，该模型对训练集的准确度如图14所示。\n\n    \n\n\n图12 Adam优化算法总代价随迭代次数的变化\n\n\n    \n\n\n图13 Adam优化算法得到的模型\n\n\n    \n\n\n图14 Adam优化算法模型对训练集的准确度\n\n可以发现，与单纯使用mini-batch算法和叠加momentum算法的模型相比，相同的迭代次数下，Adam算法很快就到达了很小的代价，其精确度也提高了许多，说明Adam确实能在很大程度上提高训练的速度。\n6.  学习率衰减在前面应用mini-batch进行模型训练的过程中，由于数据子集的不统一性，会产生许多噪声，导致总代价无法收敛到最优点而在附近徘徊。学习率衰减指将学习率随着迭代的次数不断减小，该情况下会使梯度下降的步伐不断减少，从而使得总代价最终十分接近最优点。对学习率衰减形象地用图形表示如图15所示。\n\n    \n\n\n图15 学习率衰减对模型训练的影响示意图\n\n对于学习率衰减，有几种常用的方法：一种是采用下式进行学习率衰减\n\n    \n\n\n其中，\\alpha_0为初始学习率，\\gamma为衰减率，n为代数。也可以使用如下称为指数学习率衰减的公式\n\n    \n\n\n还有一些公式，如\\alpha=\\frac {k}{\\sqrt{n}}\\alpha_0等，都具有一定的效果，甚至还可以在模型训练的过程中手动调节学习率。虽然学习率衰减确实有时能加快训练，但学习率衰减通常不是考虑的第一位，选择一个合适的超参数\\alpha往往会更有用。\n","categories":["Learning Materials"]},{"title":"深度学习方法探析——深层神经网络","url":"/2022/10/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E6%9E%90%E2%80%94%E2%80%94%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"1. 深层神经网络深层神经网络与之前的浅层神经网络的不同之处在于网络的层数更多，或者说隐藏层的层数更多，网络更深，深度学习也是基于此命名的。在过去的几年中，DLI（Deep Learning Institute）已经意识到有一些函数，只有非常深的神经网络能学会，而更浅的模型则办不到，因此深度神经网络是十分重要的。但网络的深是深在网络层数上，而不在网络节点的数量多。\n\n    \n\n\n图1 深层神经网络模型\n\n图1是一个深层神经网络的模型，它有5层，输入层算作第0层。本文用L表示层数，该模型的L=5，用n^{[l]}表示每层的节点数，这里n^{[1]}=n^{[2]}=n^{[3]}=4, n^{[4]}=3, n^{[5]}=1。\n1.1 Forward Propagation (正向传播)正向传播和浅层神经网络差别不大，也比较简单，只需不断向前迭代即可，可用(1)、(2)式表示。\n\n    \n\n\n当对多个样本进行训练时，可使用(3)、(4)式的向量形式。\n\n    \n\n\n该过程需要提供给系统A^{[0]} =X进行初始化。\n1.2Backward Propagation (反向传播)反向传播通过对总代价求导得到的da^{[l]}计算dw^{[l]}、db^{[l]}和da^{[l-1]} ，依次向前传递，计算出各dw^{[l]}和db^{[l]}，便于运用梯度下降法对参数进行优化。反向传播可由(5)-(8)式进行计算。\n\n    \n\n\n向量化形式可写成(9)-(12)式。\n\n    \n\n\n对整个正向传播和反向传播的过程进行总结可得到图2，其中系统将正向传播得到的z^{[l]}进行缓存，并传递给反向传播各模块进行计算。\n\n    \n\n\n图2 深层神经网络正反向传播过程\n\n在计算过程中，确保各参数的维数正确是避免bug产生的重要手段，故将各参数的维数总结到表1中。\n表1 深层神经网络参数维数\n\n\n\n\n    \n\n\n1.3 深层神经网络计算过程\n    \n\n\n图3 深层神经网络计算过程\n\n当运行人脸识别程序时，输入给程序一张人脸照片，如图3所示，第一层神经网络可以看做在识别图像的边缘，每个节点负责不同方向的边缘，如第一张图所示。识别到边缘后交给第二层网络进行计算，它将各个边缘组合起来变成人体的各个部位，每个结点负责不同的部位，如第二张图所示，后面层的结点可能会将各部位再进行组合变成一张人脸，对此进行识别，这就是深度神经网络在进行计算时所经历的大致过程。总的来说，这是一个由小的区域到大的区域，由简单到复杂的过程。\n1.4 编程实现深层神经网络由上面几节已经知道了深层神经网络中的几种重要计算，现将训练整个深层神经网络的过程归纳为图4所示的流程，并由此编程搭建深层神经网络。本文设计了一个4层深层神经网络作为编程对象，第0-4层分别有12288、20、7、5和1个节点。\n\n    \n\n\n图4 深层神经网络训练流程\n\n程序用到的函数及功能说明如表2所示。\n表2 深层神经网络用到的函数\n\n\n\n\n    \n\n\n现采用与浅层神经网络相同的训练集进行模型训练，迭代次数为3000次，仅为浅层神经网络程序的十分之三，学习率\\alpha同为0.005。总代价随着迭代次数的变化如图5所示，可以发现相同迭代次数下，深层神经网络的总代价略高于浅层神经网络。\n\n    \n\n\n图5 总代价随迭代次数的变化\n\n2. 深层神经网络与浅层神经网络比较对浅层神经网络进行测试发现，只可识别正面较标准的猫图片，对于角度较偏或姿势奇特的图片不可识别。现采用深层神经网络对这些难以识别的图片进行对比测试，得到的测试结果如表3所示。\n表3 浅层神经网络和深层神经网络对非标准猫图片的预测\n\n\n\n\n    \n\n\n从上表可以看出，尽管深层神经网络迭代次数仅为浅层神经网络的四分之一，深层神经网络比浅层神经网络识别正确率高得多。并且可以发现，对于这些猫图片，深层神经网络预测的概率几乎全部为1或近似于1，比浅层神经网络概率高很多，可见其性能的优异。\n3. 总结从测试结果中看，神经网络凭借较少的训练次数就可拥有远超浅层神经网络的性能，这是十分令人兴奋的。同时，深层神经网络模型对表3中的第4张图片预测错误，这时，将学习率\\alpha从0.005改为0.0075，再次对模型进行训练，得到的总代价如图6所示，比学习率为0.005时小。再次对该图片进行预测得到了如图7所示的结果，预测正确，且概率达到了1。这说明学习率的选择对模型的性能有很大影响，这也引起了我们对超参数优化的兴趣，关于模型优化方面的内容将在后续文章中阐述。\n\n    \n\n\n图6 α=0.0075时总代价随迭代次数的变化\n\n\n    \n\n\n图7 α=0.0075时的预测结果","categories":["Learning Materials"]},{"title":"深度学习方法探析——浅层神经网络","url":"/2022/10/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E6%9E%90%E2%80%94%E2%80%94%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"1.逻辑回归逻辑回归可以理解为不具备hidden layer(隐藏层)的神经网络，其模型如图1所示。逻辑回归能通过线性计算预测输入特征值对应的输出，其中的特征权重w和偏差b决定着预测的准确度，因此获得合适的w和b是此模型的重点。使用输入加权的原因可以从人的神经元中找到答案，图2是人的神经元模型，可能同时有多个电信号作用于神经元，当它们的加权和大于神经元的阈值时，其就会在轴突产生输出电信号，神经网络就是由此发展而来的。\n\n    \n\n\n\n\n图1 逻辑回归模型\n\n\n    \n\n\n图2 神经元模型\n\n1.1 梯度下降法逻辑回归利用给定的一组带标记的训练集进行代数运算获取w和b是一项艰巨的工作，甚至是难以完成的，人工智能的发展也因此一度停滞不前。梯度下降法的提出解决了这一问题，虽然其获得的可能不是最优解，但至少让这一过程有解。梯度下降法的思路是：初始随机选择参数，根据预测值与期望值的偏差反向传播误差，进而调整参数的大小。就像从山的任意位置沿着梯度的方向朝着谷底前进，谷底就是预测偏差最小的位置，也就是模型训练的目标点。表1列出了本文会用到的符号解释。\n 表1 本文用到的符号及解释 \n\n\n    \n\n\n\n当输入值多于一个时，需要程序循环多次以计算对应的预测值，但在编程时，大量使用for循环会极大影响程序执行速度。为了解决这个问题，我们尽量采用向量的形式表示各个值，应用python内嵌函数可以轻松地处理向量的运算，经过比较，向量形式比for循环形式快数百倍。因此，本文均采用向量形式进行计算。逻辑回归的过程可以分为forward propagation (向前传播)和backward propagation(向后传播)两个过程。向前传播通过上面所述的过程计算当前参数对应预测值的代价(或损失)，向后传播采用链式法则计算总代价(或总损失)对各参数的偏导数，根据设定的学习率更新参数。之后重复前述操作，直到达到理想的代价或者迭代次数为止。具体的逻辑回归模型训练过程如下：\n\n    \n\n\n\n1.2 编程实现逻辑回归现通过python编程搭建逻辑回归模型实现“猫识别”，程序采用模块化方式编写，用到的函数如表2所示。本文采用可下载的h5文件数据集进行模型训练，也可采用CSV文件数据集。\n 表2 “猫识别”程序用到的函数\n\n\n    \n\n\n本文模型训练迭代10000次，学习率采用0.005。运行程序，可以看到总代价随着训练次数逐渐减小，如图3所示。\n下面随意下载一张猫的图片交给程序进行预测，图4为交给程序的猫图片，程序对图片预测后输出该图片是猫的概率，若概率大于0.5则判定该图片有猫，并显示预测结果，如图5所示。可以看到，程序预测该图片有99.66%的概率为猫。\n\n    \n\n\n图3 逻辑回归程序不同迭代次数的总代价\n\n\n    \n\n\n\n\n图4 预测图片（含猫）\n\n\n    \n\n\n图5 预测结果（含猫）\n\n为了测试程序不会把所有图片认定为猫，再对一不含猫的图片进行预测，如图6所示。预测结果如图6所示，程序预测该图片有33.74%的概率为猫，认为这不是一张含有猫的图片。可以看出，程序可以正确分辨有无猫在图片中。\n\n    \n\n\n图6 预测图片（不含猫） \n\n\n    \n\n\n\n图7 预测结果（不含猫）\n\n经过多次测试，发现程序对正面较清晰的猫识别概率很高，有些情况下存在识别错误。另外，对于一些与猫相近的狗的正面照也存在识别为猫的情况。\n2.浅层神经网络逻辑回归可以看为只有一层的神经网络，也可以理解为人脑的一个神经元，将多个逻辑回归中的单元叠起来就变成了神经网络，如图8所示。其中，输入层也称为第0层，因此下图的神经网络被称为2层神经网络。\n\n    \n\n\n图8 神经网络模型\n\n2.1 神经网络的表示神经网络的节点数比逻辑回归多，需要对逻辑回归的向量形式做一定的调整。本文采用上标 [1]表示第1层神经网络，第0层的X可用A^{[0]}表示，w从之前的1维向量变为矩阵W，其中，为方便后续计算，已将对应的w进行转置，如(5)式所示。\n\n    \n\n\n每层的输出Z^{[i]}可通过(6)式计算\n\n    \n\n\n其中，A^{[0]}相当于第0层的输入，即X。下面以第1层为例推导该过程的维度对应关系：\n\nW^{[1]}X=\\begin{bmatrix}w_1^{[1]T}\\\\w_2^{[1]T}\\\\...\\\\w_{n_{hidden}}^{[1]T}\\end{bmatrix}\\cdot\\begin{bmatrix}\\vdots&\\vdots&\\vdots&\\vdots\\\\x_1&x_2&x_3&\\vdots\\\\\\vdots&\\vdots&\\vdots&\\vdots\\end{bmatrix}=\\begin{bmatrix}\\vdots&\\vdots&\\vdots&\\vdots\\\\w_1^{[1]T}&w_2^{[1]T}&w_3^{[1]T}&\\vdots\\\\\\vdots&\\vdots&\\vdots&\\vdots\\end{bmatrix}=\\begin{bmatrix}\\vdots&\\vdots&\\vdots&\\vdots\\\\z_1^{[1]}&z_2^{[1]}&z_3^{[1]}&\\vdots\\\\\\vdots&\\vdots&\\vdots&\\vdots\\end{bmatrix}=Z^{[1]}2.1.1 forward propagation(正向传播)只有2层的浅层神经网络的正向传播可由以下4个式子求得\n\n    \n\n\n2.1.2 backward propagation(反向传播)反向传播可总结为以下6个公式 (输出层采用sigmoid函数作为激活函数)\n\n    \n\n\n其中，(11)、(12)、(13)、(15)和(16)式原理同(2)-(4)式，现对(14)式进行适当推导。运用链式法则，可得\n\n    \n\n\n其中，\n\n    \n\n\n综合(17)-(19)式以上各式可得\n\ndZ^{[1]}=W^{[2]T}*g^{[1]'}(Z^{[1]})2.1.3 浅层神经网络训练过程具体的浅层神经网络训练过程如下(以2层为例)：\n \n2.1.4 激活函数的选择神经网络需要非线性的激活函数，因为如果激活函数是线性的，那么无论有多少隐藏层，都可以看作是一组线性组合，那么都会浓缩为1层，这显然是毫无意义的。在逻辑回归中用到的是sigmoid函数，如图9(a)所示，然而另外一种非线性函数tanh在大多数情况是更受欢迎的，如图9(b)所示，它覆盖了-1到1的值域，这在神经网络中会取得更好的效果，但如果模型所解决的是一个二分类问题，期望得到的是0或1，可以考虑在输出层使用sigmoid函数。这两个函数都存在一个问题，当z太大或太小时斜率接近于0，这会导致学习饱和，所以可以采用ReLu函数或Leaky ReLu函数代替，如图9(c)、(d)所示，他们都可以保证z较大时不错的收敛速度。\n\n    \n\n\n图9 几种激活函数 \n\n前述计算过程中，激活函数g(z)的导数经常被用到，因此本文将几种激活函数的导数整理到表3中。\n\n    \n\n\n\n\n2.1.5 随机初始化训练神经网络时，权重随机初始化是十分重要的。当把权重W全部初始化为0时，同层的隐藏单元计算着同一个函数，他们对输出的影响也全部相同，无论经过多少次迭代他们都计算着相同的函数。也就是说，这和只有一个隐藏单元没有任何差别。为了解决这一问题，我们应当将W随机初始化，而b没有这个问题，可以将其初始化为0。\n2.2 编程实现浅层神经网络现编程搭建只有一个隐藏层的浅层神经网络，隐藏层设置5个节点，用到的函数如表4所示。\n表4 浅层神经网络用到的函数 \n\n\n    \n\n\n\n为了方便比较，本文采用与逻辑回归程序相同的数据集进行训练，迭代次数同为10000次，总代价的变化如图10所示。可以发现，相同的迭代次数下，浅层神经网络比逻辑回归单节点网络的代价0.035704要小。\n\n    \n\n\n图10 浅层神经网络程序不同迭代次数的总代价\n\n\n    \n \n\n图11 预测图片（含猫）\n\n\n    \n\n\n图12 预测结果（含猫）\n\n现使用与逻辑回归程序相同的两张图片对浅层神经网络进行测试。如图11所示，程序预测该图片有99.51%的概率为猫图片，相比逻辑回归单节点99.66%的概率略有降低，但两种情况下预测的概率都接近100%，可以认为识别效果都十分不错，并不能看出优劣。为了更加清晰地比较两种模型，我们选取一张不太标准的猫图片进行识别，如图13所示。\n\n    \n\n\n图13 非标准含猫图片\n\n逻辑回归的单节点模型预测的结果如图14所示，浅层神经网络预测的结果如图15所示。\n\n    \n\n\n图14 逻辑回归单节点模型预测结果图 \n\n\n    \n\n\n图15 浅层神经网络预测结果 \n\n可以看到，浅层神经网络的预测结果比单节点模型概率高8.86%，浅层神经网络的预测能力更强。\n","categories":["Learning Materials"]},{"title":"深度学习方法探析——超参数调试和多分类模型","url":"/2022/10/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E6%9E%90%E2%80%94%E2%80%94%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95%E5%92%8C%E5%A4%9A%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/","content":"1. 超参数调试前面应用深层神经网络进行模型训练和推理的过程中遇到了这样一个情况：对一张猫的图片识别错误，概率仅为30%多，但在改变学习率后，概率变为了1，识别正确。这反应了超参数对神经网络模型训练的重要性，我们在训练神经网络的过程中常常需要不断改变各个超参数的值来对比前后性能的变化。因此，制定一套系统的超参数调试流程是十分有必要的。由于神经网络有众多超参数，在调试过程中要有一个优先级。通常，学习率\\alpha决定着模型训练的质量，需要优先考虑。其次，mini-batch的大小和隐藏单元的数目也会影响算法的运行，也需要考虑。对于Momentum梯度下降法和Adam算法中的参数\\beta、模型的层数、学习率衰减率等超参数有时也会产生影响，但优先级较低。对于Adam算法中的β_1、β_2和ε，一般选用固定值0.9、0.999和10^{-8}，不对其进行调试。如果在超参数的选择范围内均匀取值，只能覆盖少量数据，因此需要在划定的范围内随机取值。但仅仅均匀随机取样是不行的，对某些超参数来说，标尺的正确选择是必要的。对于模型层数和节点数这类超参数，在给定范围内均匀取值不会出现什么问题。但对于学习率\\alpha、Adam算法中的β，例如在0.0001到1之间随机取值，那么90%的数据会落到0.1到1之间，0.0001到0.1之间只有10%的数据，这是不均衡的。这时应该将数据范围换成对数形式，从10-4到100，再在指数上进行平均随机选取，就可以兼顾每一个数量级的数据。超参数的搜索过程可以分成两种：一种是在没有足够计算资源的情况下，可以一次只训练一个模型，并在训练的过程中不断修改超参数的值，看代价函数如何变化，进而选出最优超参数；另一种是在计算资源充足的情况下，可以同时训练多个模型，查看各模型的性能，选择代价函数最理想的模型对应的超参数。\n2. Batch标准化 (Batch Normalization)在前面训练过程优化中有提到输入标准化的问题，输入标准化可以加快学习的过程。深层神经网络中有很多隐藏层，对每个隐藏层都有前一层的A^{[l-1]}输入，要想加快W^{[l]}和b^{[l]}的训练过程，就需要对每一层的输出Z^{[l]}进行标准化，这就是Batch归一化。Batch标准化的公式为\n\n    \n\n\n有时我们可能希望隐藏层具有一些特别的分布，不希望是均值为0，方差为1的标准分布，这时可在Batch标准化中做如下操作\n\n    \n\n\n由于会对每层的输出进行标准化，任何增加的常数都会被抵消，在使用Batch标准化时可以不考虑b^{[l]}这个参数。使用Batch标准化算法配合Mini-batch进行梯度下降的算法如下。\n\n    \n\n\n除了可以加快学习的过程外，Batch标准化还可以使深层节点更好地抵抗输入数据分布的变化。在遇到训练集和测试集分布不同的情况时，对模型的推理将产生影响，这种情况被称为“Covariate shift”。Batch标准化使每层的输出保持恒定的均值和方差，当输入的分布改变时，每层的输出的变化程度就会减小，特别是对深层的节点来说，这有助于模型抵抗数据分布的改变。Batch标准化还有一个附加作用：正则化，使用不同的mini-batch计算均值和方法时，由于数据的不统一会产生一些噪声，因此在标准化和从z^{[l]}到\\tilde{z}^{[l]}的过程中都会产生一些噪声.这和Dropout正则化很像，区别在于Dropout的噪声使其对每个隐藏单元乘0或1，所以Batch标准化也会存在轻微的正则化效果。在训练中运用Batch标准化时，\\mu和σ^2是通过整个mini-batch计算出的。然而，在进行模型预测时，很多时候要逐一处理样本，这时对\\mu和σ^2的计算就没有意义了。这时就需要采用指数加权平均的方法对每个mini-batch计算出的\\mu^{[l]}和σ^{2[l]}进行运算，估计出每层的\\mu^{[l]}和σ^{2[l]}，运用到单一样本的预测中。\n3. Softmax回归 (Softmax regression)3.1 Softmax回归概念之前我们训练的全部为二分类模型，Softmax回归可以用来训练具有多个输出的模型。Softmax回归模型如图1所示，模型要对数据集分成几类就设置几个输出节点，类别的数目用C表示，每个输出层节点输出的值为该类别的概率。Softmax回归的关键是Softmax激活函数，其对输出层的输出Z[l]起到的作用为：先对Z[l]进行指数变换\n\n    \n\n\n\n然后对其进行归一化，使各节点的输出总和为1：\n\n    \n\n\n\n此时的输出即为各类别的概率。\n\n    \n\n\n图1 Softmax模型\n\nSoftmax回归的损失函数定义为\n\n    \n\n\n\n当试图减小训练集的损失时，它可以让对应的 值尽可能大。整个训练集的总代价函数为\n\n    \n\n\n\n3.2 编程实现Softmax回归本文采用Tensorflow深度学习框架，使用softmax回归实现了手部动作从0到5的识别。Tensorflow是一个不错的深度学习框架，它可以帮助我们省去很多程序的编写，特别是对于后向传播，Tensorflow可以根据编写的代价函数自动进行梯度下降，帮助我们解决了后向传播这一最复杂的问题。Tensorflow作为一种用于深度学习的编程框架，其主要包含两种目标类：Tensors和Operators，编程中应该遵守的步骤如下：\n\n    \n\n\n本文训练集采用1080张64*64 pixels的有0到5手势的图片，如图2所示，测试集为相同规格的图片120张。本文采用三层模型，0到3层的节点数分别为12288、25、12、6，学习率0.0001，采用mini-batch迭代1500代，每个mini-batch大小为32。\n\n    \n\n\n图2 训练数据集示例\n\n训练得到的总代价随迭代次数的变化如图3所示，图中的抖动是由于使用了mini-batch的方法，但总体逐渐下降，效果不错。\n\n    \n\n\n图3 总代价随迭代次数的变化\n\n该模型对训练集和测试集的准确度如图4所示，测试集比训练集准确度低很多，说明模型存在高偏差，这是由于模型过于简单造成的，这里由于训练时间较长，选择了这个适中的模型。\n\n    \n\n\n图4 训练集和测试集的准确度\n\n使用自己拍摄的0到5手势进行预测，得到的结果如表1所示，该模型具有多个输出，能够预测0到5的手势。但注意到，对于下表的测试数据，准确率不高，说明该模型确实如测试集的结果显示一样，具有较大的偏差，对新环境的适应能力不强，还有很大改进空间。\n表1 模型对0到5手势的预测结果\n\n\n    \n","categories":["Learning Materials"]},{"title":"深度学习方法探析——训练过程优化","url":"/2022/10/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%8E%A2%E6%9E%90%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E4%BC%98%E5%8C%96/","content":"1. 引言深层神经网络的训练过程往往需要花费很多时间，特别对于很深的网络，往往需要花费巨大的时间和算力，而且如果网络的结构选择不当，会造成数据欠拟合或过拟合的后果。为了尽可能减少训练深层神经网络的代价，提高模型准确度，本文从训练过程角度讨论了几种可以加速训练速度和精度的方法，包括欠拟合和过拟合的判断方法、解决过拟合的正则化方法、提高训练速度的归一化输入、减缓梯度消失和梯度爆炸的初始化方法。另外，本文还介绍了一种用于检验网络梯度下降正确性的方法——梯度检验。\n2.  训练集、验证集和测试集在深层神经网络模型训练的过程中，需要提供许多数据用于计算最优参数，这些训练用的数据被称为训练集 (train set)。可以注意到模型中还存在许多超参数，这些超参数在模型训练开始都是根据经验设置的，可以使用交叉验证集，也称验证集 (dev set)来挑选超参数，它是参与模型选择过程的。而测试集 (test set)不以任何形式参与到模型的选择中，它用于在选择好模型后对模型的运行状况进行无偏估计。我们要做的是，在训练集上对模型进行训练；然后尝试不同的模型框架，在验证集上评估这些模型，迭代选出适合的模型；最后在测试集上对该模型的运行状况进行无偏估计，通过不断的循环迭代训练出优秀的模型，该过程如图1所示。\n\n    \n\n\n图1 深层神经网络模型训练迭代流程\n\n在数据量比较小的时候，可以按照60%训练集，20%验证集，20%测试集的比例进行划分。但是在大数据时代，数据量可能是百万级别，验证集和测试集占数据总量的比例会趋向于变得更小。有时，如果不需要无偏估计，也可以只设置训练集和验证集，人们通常把这种情况称为只有训练集和测试集，实际上是将验证集过度拟合到了验证集，从而把测试集当做验证集使用。训练集、验证集和测试集的对比如表1所示。\n表1 训练集、验证集、测试集对比\n\n\n    \n\n\n3. 偏差和方差3.1 偏差和方差估计的偏差 (bias)被定义为\n\n    \n\n\n其中，期望作用在所有数据上，\\theta是用于定义数据生成分布的\\theta的真实值。估计量的方差 (variance)为\n\n    \n\n\n其中，随机变量是训练集。估计量的方差告诉我们，当独立地从潜在的数据生成过程中重采样数据集时，如何期望估计的变化。正如我们希望估计的偏差较小，我们也希望其方差较小。\n3.2 欠拟合和过拟合当讨论偏差和方差时，就不得不研究欠拟合和过拟合的问题。如图2所示，图中的绿点为一组数据集，图2 (a)对数据集拟合了一条直线，得到了一个逻辑回归拟合，它并不能很好地拟合该数据，这就是欠拟合 (underfitting)的情况，该情况下偏差高；如果我们使用一个复杂的网络模型，比如深度神经网络或含有隐藏单元的神经网络，可能就非常适用于这个数据集，如图2 (c)所示，但这显然也不是一种很好的拟合方式，它过度地拟合了训练集中的特殊情况，这就是过拟合 (overfitting)，该情况下方差高。图2 (b)就是一种很好的拟合方式，其复杂程度适中，拟合数据更加合理，可以称这种情况为适度拟合 (just right)，这种情况下偏差和方差均较小。\n\n    \n\n\n图2 三种拟合情况\n\n3.3 欠拟合和过拟合的判断现假设训练集和验证集的最优化误差为0，我们可以通过比较训练集和验证集的误差大小判断拟合情况。若某情况下训练集的误差小，而验证集的误差大，说明过度拟合了训练集的数据，为高方差；若训练集和验证集的误差都很大且二者相当，则训练集数据没有得到很好的拟合，为高偏差；若训练集和验证集的误差都很大且验证集误差更大一些，则为高偏差高方差的情况，在某些维度上的数据区域偏差高，某些维度上的数据方差高，是最坏的一种情况；若训练集和验证集误差都很小，该情况就为适度拟合。现将欠拟合和过拟合判断方法总结为表2。\n表2 欠拟合和过拟合判断方法\n\n\n    \n\n\n3.4 降低偏差和方差的方法训练网络的最低标准就是能够拟合数据，因此在训练完模型后应该首先评估网络的偏差是否很大。如果发现网络的偏差很大，可以常识几个方法：选择一个新的网络，比如含有更多隐藏层或者隐藏单元的网络；花费更多时间来训练网络；或者尝试更先进的优化算法。其中，使用规模更大的网络通常是有用的。如果检测到网络的方差很高，最好的办法就是采用更多的数据。但有时我们无法获得更多数据，这时可以尝试使用正则化的方式降低网络的方差，这将在下一节中讲述。\n4. 正则化4.1 L^2正则化现从逻辑回归模型着手，对L^2正则化进行研究。对逻辑回归模型实施正则化后，其总代价为\n\n    \n\n\n其中涉及到了范数的概念，L^p范数定义如下\n\n    \n\n\n其中p∈R ,p≥1。由于该过程用到了w的L^2范数，因此称其为称为L^2正则化，‖w‖_2^2的计算过程为\n\n    \n\n\n这里只将参数w正则化的原因是，w几乎包含了所有参数，而b只是一个参数，可以忽略不计。将L^2正则化推广到神经网络中，(3)式变为\n\n    \n\n\n其中，‖W^{[l] } ‖_F^2的计算过程为\n\n    \n\n\n该矩阵范数被称作“弗罗贝尼乌斯范数 (Frobenius norm)”，用下标F标注。正则化后的dW只需在原有基础上减去正则项的导数即可：\n\n    \n\n\n其中，(back prop)代表未正则化前的dW^{[l]} 。更新后的W^{[l]}为\n\n    \n\n\n可见，L^2正则化每次更新都在原有的W^{[l]}上先乘一个小于1点的数再进行梯度下降，因此L^2正则化也被称为“权重衰减”。\n4.2 正则化减少过拟合的原理如前所述，过拟合情况的发生是由于网络过于复杂，拟合了过多的训练集数据，我们希望简化网络模型，正则化减少过拟合的原理可以从两方面直观理解。一方面，正则化朝着减小权重的方向更新W^{[l]} ，可以假设某些W^{[l]}被更新到接近于0，这样对应的节点就相当于断开了，网络得到简化。实际上权重的衰减并不会这么大，但可以一定程度简化网络，达到减缓过拟合的效果。另一方面，我们所用的激活函数，如sigmoid函数和tanh函数，在0附近近似于线性，正则化将参数往减小的方向调整，假设调整幅度很大，正则化参数λ足够大，就会使得z^{[l]}落在线性区域。而线性的激活函数无论有多少层，对输出而言都只有一层，这就使得复杂的网络得到了简化。虽然在实际情况下每层输出不会变为线性，但可以一定程度地减缓过拟合。\n4.3 Dropout正则化除L^2正则化外，还有一种十分有效的正则化方法——Dropout正则化，可以理解为随机失活。Dropout的原理是：对每一层的节点设置失活概率，该层中的每个节点都以该概率随机被删除，这在一定程度上简化了网络，可以达到减缓过拟合的效果，如图3所示。\n\n    \n\n\n图3 实施Dropout前后的网络\n\nDropout正则化可以减缓过拟合的原因可以理解为：每个节点的输入都可能随机消失，所以在训练过程中不会过分依赖任何一个节点，这会产生收缩权重的平方范数的效果，这和L^2正则化相类似。值得注意的是，为了不对预测结果在范围上产生变化，需要在每层激活函数的输出数据上除以 (1-失活概率)，这起到了归一化的作用。Dropout的一大缺点就是代价函数 J不再被明确定义，或者说在某种程度上很难计算，每次迭代，都会随机移除一些节点，这使得梯度下降的性能很难得到检验。因此，通常可以先关闭Dropout，检查代价函数 J单调递减后再打开Dropout进行迭代训练，这有助于减少程序中的错误。\n4.4 正则化实际效果测试通过理论推理，可以得出正则化可以减缓过拟合的结论，下面将使用python编程实现L^2正则化和Dropout正则化，比较实际结果与理论推理是否一致。首先不适用正则化，对一组数据进行拟合，该组数据有两个特征向量，通过图形化展示如图4所示，不同的y以不同的颜色表示。\n\n    \n\n\n图4 待分类数据\n\n现使用一个三层网络对其进行训练，每层节点数分别为2、20、3、1，迭代30000次，得到的总代价曲线如图5所示，训练集和验证集准确度如图6所示，验证集误差比训练集误差大。将训练出的分类器不同部分以不同颜色填图得到图7，可以发现有部分特例也被分类器拟合了，存在过拟合的情况。\n\n    \n\n\n图5 未正则化时的总代价曲线\n\n\n    \n\n\n图6 未正则化时的测试验证集准确度\n\n\n    \n\n\n图7 未正则化时训练得到的模型\n\n4.4.1 L^2正则化对上述模型实施L^2正则化，设置参数λ为0.7，其余不变，这时总代价曲线如图8所示，训练集和验证集准确度如图9所示。\n\n    \n\n\n图8 L2正则化时的总代价曲线\n\n\n    \n\n\n图9 L2正则化时的测试验证集准确度\n\n可以看到，此时验证机误差和训练集误差十分接近，过拟合情况得到了改善。对模型进行颜色填图，得到的分类器模型如图10所示。该模型没有将特殊点拟合进去，实现了不错的二分类，可见L^2正则化的效果是不错的。\n\n    \n\n\n图10 L2正则化时训练得到的模型\n\n4.4.2 Dropout正则化现对最初的模型进行Dropout正则化，将所有节点的失活概率都设置为0.14，其余不变，得到的总代价曲线如图11所示，训练集和验证集准确度如图12所示。\n\n    \n\n\n图11 Dropout正则化时的总代价曲线\n\n\n    \n\n\n图12 Dropout正则化时的测试验证集准确度\n\n使用Dropout正则化后，验证集的准确度超过了训练集，说明适当简化网络后得到了更佳的性能。得到的分类器模型如图13所示，该模型也没有将特殊点拟合进去，并且对分界线上得数据进行了合理分配，训练得到的模型性能优于前者。可见，Dropout正则化在一定程度上能缓解数据的过拟合。\n\n    \n\n\n图13 Dropout正则化时训练得到的模型\n\n4.5 Early Stopping除了L^2正则化和Dropout正则化外，Early Stopping也是一种避免数据过拟合的有效方法。在未进行多少次迭代时，参数W^{[l]}的值很小，随着迭代次数的增加，W^{[l]}的值越来越大，此时就可能会产生过拟合。Early Stopping要做的就是在方差恶化的时候及时停止迭代，如图14所示，后半段验证集误差随着迭代次数增加而增大，方差进而增大，在最优迭代次数处停止迭代可以得到较好的偏差和方差的权衡。\n\n    \n\n\n图14 训练验证集误差随迭代次数的变化\n\nEarly Stopping的优点是：不必像L^2正则化一样不断测试λ的值以便找到合适的超参数，它只需运行一次梯度下降即可。但它在停止迭代的同时也停止了对总代价的优化，因此它可能影响偏差的大小。换句话说，它是在进行偏差和方差的权衡，降低了方差可能以提高偏差为代价，而不能用两种方法分别解决这两个问题，但在一定程度上这种方法是可行的。\n5.  归一化输入归一化输入是一个很好的加速训练过程的方法，归一化的过程可以分为两步：均值归零化和方差归一化。均值归零化的公式为\n\n    \n\n\n其中，\\mu为数据的均值\n\n    \n\n\n方差归一化的公式为\n\n    \n\n\n其中，σ^2为数据的方差\n\n    \n\n\n归一化输入使输入全部变为均值为0，方差为1的数据，该过程可形象地表现为图15的形式，为便于展示，假定该组数据只有两个特征向量。\n\n    \n\n\n图15 归一化输入\n\n下面说明归一化输入可以加速训练过程的原因，当使用未归一化的数据时，其不同特征向量的均值和方差可能有所不同，这将导致不同的特征向量对应的W_i的均值和方差不同，他们的范围可能相差数十甚至上百倍。现以一个二维的W为例，绘制其总代价函数，如图16(a)所示，这是未输入归一化的情形，两个维度存在较大范围差。当在其上进行梯度下降时，必须取很小的步长，而且是迂回下降的，因为这个函数是狭长的。而通过如图16(b)的归一化后的数据训练出的W对应的总代价函数为一个碗形，可以很容易地沿一条线进行梯度下降直至谷底，有效节省了训练时间。\n\n    \n\n\n图16 归一化前后总代价函数梯度下降\n\n6. 权重初始化6.1 梯度消失和梯度爆炸当训练深度较深的深层神经网络时，通过反向传播计算出的梯度有时会变得特别大或特别小，甚至是以指数形式变化，这会极大地加大训练的难度，这就是梯度爆炸和梯度消失。当梯度变得特别小时，每次梯度下降的步长都变得很小，增加了达到谷底的迭代次数；当梯度变得特别大时，梯度下降法只能在谷底两次徘徊，而无法到达谷底，这都十分影响训练的速度和精度。造成梯度消失和梯度爆炸的原因是：在深层神经网络的训练过程中中一般都会存在这一项 ∏_{(l=1)}^LW^{[l]} X，深层网络中的L一般很大，只要W^{[l]} 略微大于1，该项将会变得非常大，反之亦然。这就导致了激活函数的输出很大或很小，同理，对应的梯度也会变得非常大或非常小。\n6.2 权重初始化缓解梯度消失和梯度爆炸的一种方法就是更谨慎地选择随机初始化参数，虽然这不能从根本上解决问题，但会有所帮助。对于一个神经元来说，其输出和输入有如下关系\n\n    \n\n\n其中，n表示神经网络输入的特征数量。为了防止Z过大或过小，我们希望在n较大时减小W_i，在n较小时增大W_i，比较好的方法就是将W_i的方差Var(W_i )设置为1⁄n，我们要做的就是在对每层的权重随机初始化时，在其上乘1/\\sqrt{n^{[l-1]}}。特别地，若使用ReLu函数作为激活函数，将Var(W_i )设置为1⁄n通常是更佳的，也就是在随机初始化的权重上乘2⁄\\sqrt{n^{[l-1]}}，对于tanh函数来说，1⁄n就是一个不错的选择。\n6.3 几种权重初始化的实际效果测试这里使用和正则化时相同的训练验证集进行训练，模型仍为一个三层网络每层节点数分别为2、20、3、1，迭代15000次，依次使用零初始化、随机初始化（参数初始化很大）和He初始化对模型进行训练，对比三种情况的拟合效果。\n6.3.1 零初始化将所有参数初始化为0，将训练到的分类器模型进行填图得到图17，训练验证集的准确度如图18所示。\n\n    \n\n\n图17 零初始化时的模型\n\n\n    \n\n\n图18 零初始化时训练验证集的准确度\n\n可见，这个模型是十分糟糕的，准确度仅在一半左右，将所有输入都预测为0，这验证了我们之前所说的，如果将参数初始化为0，整个网络的对称性会使得每个节点都在做同样的事，这使得每层都等效于只有一个节点，使得这个网络性能和线性的逻辑回归模型差不多，甚至更差。\n6.3.2 随机初始化（参数初始化很大）为了模拟梯度爆炸的情况，我们将随机初始化的参数都乘10，其余设置都与6.3.1节相同。总代价随迭代次数的变化如图19所示，初始总代价很大，这是由初始权重很大造成的，其间总代价出现了几次上升，这正是图16(a)代表的情况，由于梯度爆炸，在谷底两侧不断徘徊。训练得到的模型如图20所示，训练验证集的准确度如图21所示。\n\n    \n\n\n图19 随机初始化总代价曲线（参数初始化很大）\n\n\n    \n\n\n图20 随机初始化时的模型\n\n\n    \n\n\n图21 随机初始化时训练验证集的准确度\n\n可见，梯度爆炸的情况下，训练过程被延长，并且模型效果不佳，应该设法避免这种情况发生。\n6.3.3 He初始化He初始化是用第一个使用它的作者命名的，就是之前提到的对激活函数是ReLu时的初始化方法，其在随机初始化的权重上乘2⁄\\sqrt{n^{[l-1]}}。He初始化下总代价随迭代次数的变化如图22所示，总代价随迭代次数的衰减很快。训练得到的模型如图23所示，训练验证集的准确度如图24所示。\n\n    \n\n\n图22 He初始化总代价曲线\n\n\n    \n\n\n图23 He初始化时的模型\n\n\n    \n\n\n图24 He初始化时训练验证集的准确度\n\n在这种初始化方式下，模型的准确度表现良好，可见好的初始化对缓解梯度消失或梯度爆炸的重要性。\n7.  梯度检验在训练神经网络时，有时虽然程序能够正常运行，但很难检查反向传播是否完全正常工作。一种比较好的评估方法就是采用数值逼近，我们称其为梯度检验。梯度检验通过取代价函数上某点左右两侧十分临近的两点的函数值对该点的导数进行估计，这里采用双边公差的原因是其误差比单边公差小。进行梯度检验要进行的第一件事就是将网络中的参数W^{[1]}  、b^{[1]}  、W^{[2]}  、b^{[2]}  、⋯、W^{[L]}  、b^{[L]} 转换成一个向量\n\n    \n\n\n将dW^{[1]}、db^{[1]}、dW^{[2]}、db^{[2]}、⋯、dW^{[L]}、db^{[L]}转换成一个向量\n\n    \n\n\n总代价函数J是\\theta的函数，可以写成J(θ_1,θ_2,θ_3,⋯)，接下来要做的就是对每个组成元素θ_i使用双边估计得到\n\n    \n\n\n最后对得到的两个向量dθ和dθ_{approx}进行比较来估计反向传播的正确性，这里采用下式对两向量进行比较\n\n    \n\n\n如果计算得到的值为10^{−7}或更小，说明导数逼近很有可能是正确的；如果它的值在10^{−5}范围内，就应该引起注意，模型训练的过程中可能存在问题。发现网络存在问题时，应该仔细检查所有θ项，查看是否有某一个特定的θ_i使得dθ和dθ_{approx}相差较大，并用其追踪求导运算，然后进行调试，直到(18)式的计算结果达到10^{−7}的量级为止。\n","categories":["Learning Materials"]}]